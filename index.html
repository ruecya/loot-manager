<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>전리품 분배 매니저 v5 (레인별 1인1개 + 명단 순서 변경)</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin: 16px; }
    .row { display:flex; gap:12px; flex-wrap: wrap; align-items: center; }
    .card { border:1px solid #ddd; border-radius:12px; padding:12px; margin:12px 0; }
    button { padding:8px 12px; border-radius:10px; border:1px solid #ccc; background:#fff; cursor:pointer; }
    button.primary { border-color:#111; font-weight:600; }
    button.danger { border-color:#c00; color:#c00; }
    input, select, textarea { padding:8px; border-radius:10px; border:1px solid #ccc; }
    textarea { width: min(860px, 100%); }
    table { width:100%; border-collapse: collapse; }
    th, td { border-bottom:1px solid #eee; padding:8px; text-align:left; vertical-align: top; }
    .muted { color:#666; }
    .pill { padding:2px 10px; border:1px solid #ddd; border-radius:999px; font-size:12px; }
    .hr { height:1px; background:#eee; margin:10px 0; }
    .warn { color:#b45309; }
    .small { font-size:12px; }
    details summary { cursor:pointer; }
    code { background:#f6f6f6; padding:2px 6px; border-radius:6px; }
    .drag-handle{ cursor:grab; user-select:none; font-weight:700; }
    tr.drag-over{ outline:2px dashed #999; outline-offset:-4px; }
  </style>
</head>
<body>
  <h2>전리품 분배 매니저 v5</h2>

  <div class="row">
    <button id="tabRoster" class="primary">명단/목록</button>
    <button id="tabFixed">고정템 레인</button>
    <button id="tabLoot">전리템 레인</button>
    <button id="tabLogs">이력/백업</button>
  </div>

  <div id="view"></div>

<script>
/**
 * v5 변경 핵심(요청 반영)
 * ✅ "고정템"과 "전리템"은 각각 1인 1개 (레인별로 별도 관리)
 *   - 배치(보스 1회)에서:
 *     - 고정템 레인: 사람당 최대 1개
 *     - 전리템 레인: 사람당 최대 1개
 *   - 즉, 같은 사람이 같은 배치에서 고정 1개 + 전리 1개는 가능
 *
 * 유지 기능
 * - 토큰: 전리 패스 시 +1 생성, 우선권(토큰1) 고정/전리 모두 사용 가능
 * - 우선권은 해당 레인에서 "배치 미수령자"만 가능
 * - 레인별 참여자 ON/OFF 분리
 * - 전리템 아이템명 목록(선택용) 관리
 * - 명단 순서 임의 변경(드래그/▲▼)
 */

const STORAGE_KEY = "loot_manager_v5";

// --- Reorder helpers (명단 순서 변경) ---
let _dragPlayerId = null;
function moveArrayItem(arr, fromIdx, toIdx){
  if(fromIdx === toIdx) return arr;
  const copy = arr.slice();
  const [it] = copy.splice(fromIdx, 1);
  copy.splice(toIdx, 0, it);
  return copy;
}
function reorderPlayersById(dragId, dropId){
  if(!dragId || !dropId || dragId===dropId) return;
  const fromIdx = state.players.findIndex(p=>p.id===dragId);
  const toIdx   = state.players.findIndex(p=>p.id===dropId);
  if(fromIdx<0 || toIdx<0) return;
  state.players = moveArrayItem(state.players, fromIdx, toIdx);
  logEvent("ROSTER_REORDER","(명단)", null, `명단 순서 변경: ${fromIdx+1} → ${toIdx+1}`, { fromIdx, toIdx, dragId, dropId });
  saveState();
}
function reorderPlayersByIndex(i, delta){
  const j = i + delta;
  if(i<0 || j<0 || i>=state.players.length || j>=state.players.length) return;
  state.players = moveArrayItem(state.players, i, j);
  logEvent("ROSTER_REORDER","(명단)", null, `명단 순서 변경: ${i+1} ↔ ${j+1}`, { fromIdx:i, toIdx:j });
  saveState();
}

// Utils
function nowTs(){ return Date.now(); }
function fmt(ts){
  const d = new Date(ts);
  const pad = n => String(n).padStart(2,"0");
  return `${d.getFullYear()}-${pad(d.getMonth()+1)}-${pad(d.getDate())} ${pad(d.getHours())}:${pad(d.getMinutes())}:${pad(d.getSeconds())}`;
}
function safeText(s, fallback="(미입력)"){
  const t = (s || "").trim();
  return t ? t : fallback;
}

function normalizeGitHubTextUrl(u){
  // Accept:
  // - https://github.com/<owner>/<repo>/blob/<branch>/path
  // Convert to:
  // - https://raw.githubusercontent.com/<owner>/<repo>/<branch>/path
  const url = (u || "").trim();
  if(!url) return url;
  try{
    const m = url.match(/^https:\/\/github\.com\/([^\/]+)\/([^\/]+)\/blob\/([^\/]+)\/(.+)$/);
    if(m){
      const owner = m[1], repo = m[2], branch = m[3], path = m[4];
      return `https://raw.githubusercontent.com/${owner}/${repo}/${branch}/${path}`;
    }
  }catch(e){}
  return url;
}

function looksLikeHtml(text){
  const t = (text || "").trim().slice(0, 200).toLowerCase();
  return t.includes("<!doctype html") || t.includes("<html") || t.includes("<head") || t.includes("<body");
}

function stripBom(s){
  if(!s) return s;
  return s.charCodeAt(0) === 0xFEFF ? s.slice(1) : s;
}


// State
function defaultState(){
  return {
    players: [],
    fixedPointer: 0,
    lootPointer: 0,
    fixedItemName: "고정템",
    lootCatalog: [],
    batchId: null,
    // 레인별 배치 수령 기록 (요청사항)
    batchReceivedFixed: {},
    batchReceivedLoot: {},
    logs: [],
    ui: { showDangerButtons: false }
  };
}
let state = loadState();

function loadState(){
  try{
    const raw = localStorage.getItem(STORAGE_KEY);
    if(!raw) return defaultState();
    const parsed = JSON.parse(raw);
    return {
      ...defaultState(),
      ...parsed,
      ui: { ...defaultState().ui, ...(parsed.ui||{}) },
      batchReceivedFixed: parsed.batchReceivedFixed || {},
      batchReceivedLoot: parsed.batchReceivedLoot || {}
    };
  }catch(e){
    console.warn(e);
    return defaultState();
  }
}
function saveState(){
  localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
}
function logEvent(type, itemName, receiverId, detail, meta = {}){
  state.logs.unshift({ ts: nowTs(), type, itemName, receiverId, detail, meta });
  saveState();
}

// Batch
function startBatch(){
  state.batchId = nowTs();
  state.batchReceivedFixed = {};
  state.batchReceivedLoot = {};
  logEvent("BATCH_START", "(배치)", null, "이번 보스(배치) 시작: 레인별 1인1개 초기화", { batchId: state.batchId });
  saveState();
}
function canReceive(which, playerId){
  if(which === "fixed") return !state.batchReceivedFixed[playerId];
  return !state.batchReceivedLoot[playerId];
}
function markReceived(which, playerId){
  if(which === "fixed") state.batchReceivedFixed[playerId] = true;
  else state.batchReceivedLoot[playerId] = true;
  saveState();
}
function batchSummary(which){
  if(which === "fixed") return Object.keys(state.batchReceivedFixed || {}).length;
  if(which === "loot") return Object.keys(state.batchReceivedLoot || {}).length;
  return (Object.keys(state.batchReceivedFixed || {}).length + Object.keys(state.batchReceivedLoot || {}).length);
}

// Lane roster / pointer
function laneKey(which){ return which === "fixed" ? "activeFixed" : "activeLoot"; }
function lanePlayers(which){
  const key = laneKey(which);
  return state.players.filter(p => !!p[key]);
}
function laneCount(which){ return lanePlayers(which).length; }

function clampPointer(which){
  const n = laneCount(which);
  if(n === 0){
    if(which==="fixed") state.fixedPointer = 0;
    else state.lootPointer = 0;
    return;
  }
  if(which==="fixed") state.fixedPointer = ((state.fixedPointer % n) + n) % n;
  else state.lootPointer = ((state.lootPointer % n) + n) % n;
}
function pointerValue(which){
  clampPointer(which);
  return which==="fixed" ? state.fixedPointer : state.lootPointer;
}
function setPointerValue(which, v){
  if(which==="fixed") state.fixedPointer = v;
  else state.lootPointer = v;
  clampPointer(which);
  saveState();
}
function stepPointer(which, step=1){
  const n = laneCount(which);
  if(n === 0) return;
  const p = pointerValue(which);
  setPointerValue(which, (p + step) % n);
}
function peekEligibleCurrent(which){
  const arr = lanePlayers(which);
  const n = arr.length;
  if(n === 0) return { player:null, offset:0, exhausted:true };

  const start = pointerValue(which);
  for(let i=0; i<n; i++){
    const idx = (start + i) % n;
    const p = arr[idx];
    if(canReceive(which, p.id)){
      return { player:p, offset:i, exhausted:false };
    }
  }
  return { player:null, offset:0, exhausted:true };
}
function normalizePointerToEligible(which){
  const n = laneCount(which);
  if(n === 0){
    alert("해당 레인 참여자가 없습니다. (명단에서 ON 설정)");
    return false;
  }
  const peek = peekEligibleCurrent(which);
  if(peek.exhausted){
    alert("이번 배치에서 받을 사람이 없습니다. 새 보스면 [이번 보스 시작]을 눌러주세요.");
    return false;
  }
  if(peek.offset > 0){
    stepPointer(which, peek.offset);
    logEvent("AUTO_SKIP_BATCH", "(자동)", null,
      `${which==="fixed"?"고정":"전리"} 레인: 레인별 1인1개로 ${peek.offset}명 자동 스킵`,
      { which, skipped: peek.offset, batchId: state.batchId }
    );
  }
  return true;
}
function getCurrentEligible(which){
  const arr = lanePlayers(which);
  if(arr.length === 0) return null;
  const idx = pointerValue(which);
  return arr[idx] || null;
}

// Player ops
function addPlayer(name){
  if(state.players.length >= 50) return alert("최대 50명까지 가능합니다.");
  const id = crypto.randomUUID ? crypto.randomUUID() : String(Math.random()).slice(2);
  state.players.push({
    id,
    name,
    activeFixed: true,
    activeLoot: true,
    fixedCount: 0,
    lootCount: 0,
    tokens: 0
  });
  saveState();
}
function parseNames(text){
  return (text || "")
    .split(/[\n,|\t]+/g)
    .map(s => s.trim())
    .filter(Boolean);
}
function addPlayersBulk(text){
  const parts = parseNames(text);
  if(parts.length === 0) return;

  const existing = new Set(state.players.map(p => p.name.trim()));
  const seen = new Set();
  const unique = [];
  for(const n of parts){
    if(existing.has(n)) continue;
    if(seen.has(n)) continue;
    unique.push(n);
    seen.add(n);
  }
  if(unique.length === 0){
    alert("추가할 새 인원이 없습니다. (중복이거나 비어있음)");
    return;
  }
  const room = 50 - state.players.length;
  const toAdd = unique.slice(0, Math.max(0, room));
  toAdd.forEach(addPlayer);

  logEvent("ROSTER_BULK_ADD", "(명단)", null, `대량 추가: ${toAdd.length}명`, { added: toAdd });
  if(unique.length > room){
    alert(`최대 50명 제한으로 ${toAdd.length}명만 추가했습니다. (초과 ${unique.length - room}명)`);
  }
  saveState();
}
function setTodayParticipantsForLane(which, text){
  const names = parseNames(text);
  if(names.length === 0) return alert("이름을 붙여넣어주세요.");
  const set = new Set(names.map(s=>s.trim()));
  const key = laneKey(which);
  state.players.forEach(p => { p[key] = set.has(p.name.trim()); });
  clampPointer(which);
  logEvent("ROSTER_TODAY_SET", "(명단)", null, `오늘 참여자만 ON (${which})`, { which, names });
  saveState();
}
function setAllForLane(which, on){
  const key = laneKey(which);
  state.players.forEach(p => p[key] = !!on);
  clampPointer(which);
  logEvent(on ? "ROSTER_ALL_ON" : "ROSTER_ALL_OFF", "(명단)", null, `${which} 전체 ${on?"ON":"OFF"}`, { which });
  saveState();
}
function setBothLanesFromNames(text){
  const names = parseNames(text);
  if(names.length === 0) return alert("이름을 붙여넣어주세요.");
  const set = new Set(names.map(s=>s.trim()));
  state.players.forEach(p=>{
    const on = set.has(p.name.trim());
    p.activeFixed = on;
    p.activeLoot = on;
  });
  clampPointer("fixed"); clampPointer("loot");
  logEvent("ROSTER_TODAY_SET_BOTH", "(명단)", null, "오늘 참여자만 ON (고정+전리)", { names });
  saveState();
}
function resetPointers(){
  state.fixedPointer = 0;
  state.lootPointer = 0;
  clampPointer("fixed"); clampPointer("loot");
  logEvent("POINTER_RESET", "(포인터)", null, "고정/전리 포인터를 1번으로 리셋");
  saveState();
}
function setPointerToName(which, name){
  const arr = lanePlayers(which);
  if(arr.length === 0) return alert("해당 레인 참여자가 없습니다.");
  const idx = arr.findIndex(p => p.name.trim() === name.trim());
  if(idx < 0) return alert("해당 레인 참여자(ON)에서 이름을 찾지 못했습니다.");
  setPointerValue(which, idx);
  logEvent("POINTER_SET", "(포인터)", null, `${which} 포인터를 ${name}부터 시작`);
  saveState();
}

// GitHub roster.txt load
function parseRosterText(text){
  return (text || "")
    .split(/\r?\n/g)
    .map(s => s.trim())
    .filter(s => s && !s.startsWith("#"));
}
async function fetchRosterFromUrl(url){
  let u = normalizeGitHubTextUrl((url || "").trim());
  if(!u) return alert("roster.txt URL을 입력하세요.");
  try{
    const res = await fetch(u, { cache: "no-store" });
    if(!res.ok) throw new Error("HTTP " + res.status);
    let txt = stripBom(await res.text());
    if(looksLikeHtml(txt)) return alert("불러오기 실패: GitHub raw 주소가 아닌 것 같습니다. (github.com/blob/... 말고 raw.githubusercontent.com 주소를 넣어주세요)");
    const names = parseRosterText(txt);
    if(names.length === 0) return alert("roster.txt에서 이름을 찾지 못했습니다.");

    const unique = [];
    const seen = new Set();
    for(const n of names){
      if(seen.has(n)) continue;
      unique.push(n);
      seen.add(n);
    }
    const finalNames = unique.slice(0, 50);

    if(!confirm(`roster.txt에서 ${finalNames.length}명을 불러옵니다.\n현재 명단을 덮어쓸까요?`)) return;

    state.players = [];
    state.fixedPointer = 0;
    state.lootPointer = 0;

    finalNames.forEach(addPlayer);
    state.players.forEach(p => { p.activeFixed = true; p.activeLoot = true; });

    resetPointers();
    logEvent("ROSTER_FROM_TXT", "(명단)", null, `roster.txt 불러오기(덮어쓰기): ${finalNames.length}명`, { url: u, names: finalNames });
    saveState();
    alert("명단을 불러왔습니다.");
  }catch(e){
    alert("불러오기 실패: " + (e.message || e));
  }
}
function exportRosterTxt(){
  const lines = state.players.map(p => p.name);
  const content = lines.join("\n") + "\n";
  const blob = new Blob([content], { type:"text/plain;charset=utf-8" });
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = "roster.txt";
  a.click();
  URL.revokeObjectURL(url);

// GitHub loot_items.txt load (전리품 목록 가져오기)
function parseLootItemsText(text){
  return (text || "")
    .split(/\r?\n/g)
    .map(s => s.trim())
    .filter(s => s && !s.startsWith("#"));
}
async function fetchLootItemsFromUrl(url){
  let u = normalizeGitHubTextUrl((url || "").trim());
  if(!u) return alert("loot_items.txt URL을 입력하세요.");
  try{
    const res = await fetch(u, { cache: "no-store" });
    if(!res.ok) throw new Error("HTTP " + res.status);
    let txt = stripBom(await res.text());
    if(looksLikeHtml(txt)) return alert("불러오기 실패: GitHub raw 주소가 아닌 것 같습니다. (github.com/blob/... 말고 raw.githubusercontent.com 주소를 넣어주세요)");
    const items = parseLootItemsText(txt);
    if(items.length === 0) return alert("loot_items.txt에서 아이템을 찾지 못했습니다.");

    const seen = new Set();
    const uniq = [];
    for(const it of items){
      if(seen.has(it)) continue;
      seen.add(it);
      uniq.push(it);
    }

    if(!confirm(`loot_items.txt에서 ${uniq.length}개 아이템을 불러옵니다.\n현재 전리템 목록을 덮어쓸까요?`)) return;
    state.lootCatalog = uniq;
    logEvent("LOOT_CATALOG_FROM_TXT", "(전리목록)", null, `loot_items.txt 불러오기(덮어쓰기): ${uniq.length}개`, { url: u, items: uniq });
    saveState();
    alert(`전리품 목록을 불러왔습니다. (${uniq.length}개)\n예: ${uniq.slice(0,5).join(", ")}${uniq.length>5?" ...":""}`);
  }catch(e){
    alert("불러오기 실패: " + (e.message || e));
  }
}



// Loot catalog
function setLootCatalogFromText(text){
  const names = (text || "")
    .split(/\r?\n/g)
    .map(s=>s.trim())
    .filter(s=>s && !s.startsWith("#"));
  const seen = new Set();
  const uniq = [];
  for(const n of names){
    if(seen.has(n)) continue;
    seen.add(n);
    uniq.push(n);
  }
  state.lootCatalog = uniq;
  logEvent("LOOT_CATALOG_SET", "(전리목록)", null, `전리템 목록 저장: ${uniq.length}개`);
  saveState();
}
function exportLootCatalogTxt(){
  const lines = (state.lootCatalog || []);
  const content = lines.join("\n") + "\n";
  const blob = new Blob([content], { type:"text/plain;charset=utf-8" });
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = "loot_items.txt";
  a.click();
  URL.revokeObjectURL(url);
}

// Priority (Token)
function prioritySelector(which, currentId){
  const sel = document.createElement("select");
  const key = laneKey(which);
  const candidates = state.players
    .filter(p => !!p[key] && p.tokens >= 1 && p.id !== currentId && canReceive(which, p.id))
    .sort((a,b)=> b.tokens - a.tokens || a.name.localeCompare(b.name));

  sel.appendChild(el("option", { value:"" }, candidates.length ? "우선권 요청자 선택" : "우선권 요청자 없음"));
  candidates.forEach(p=>{
    sel.appendChild(el("option", { value:p.id }, `${p.name} (토큰 ${p.tokens})`));
  });
  return sel;
}
function priorityGive(which, itemName, claimantId){
  if(!normalizePointerToEligible(which)) return;
  const cur = getCurrentEligible(which);
  if(!cur) return;

  const claimant = state.players.find(p => p.id === claimantId) || null;
  if(!claimant) return alert("요청자를 선택하세요.");
  if(!claimant[laneKey(which)]) return alert("요청자가 해당 레인에서 OFF 상태입니다.");
  if(claimant.tokens < 1) return alert("요청자 토큰이 부족합니다. (필요: 1)");
  if(!canReceive(which, claimant.id)) return alert("요청자는 이번 배치에서 이미 1개를 받았습니다. (우선권 불가)");
  if(claimant.id === cur.id) return alert("현재 차례자 본인은 우선권 요청 대상이 아닙니다.");

  const finalItemName = safeText(itemName);

  // Token 이동(양보 보상)
  claimant.tokens -= 1;
  cur.tokens += 1;

  if(which === "fixed") claimant.fixedCount += 1;
  else claimant.lootCount += 1;

  markReceived(which, claimant.id);

  logEvent(
    which === "fixed" ? "PRIORITY_FIXED" : "PRIORITY_LOOT",
    finalItemName,
    claimant.id,
    `우선권 적용: 원차례자=${cur.name} → 수령자=${claimant.name} / 토큰 1개 ${cur.name}에게 이동`,
    { which, curId: cur.id, claimantId: claimant.id, tokenTransfer: 1, batchId: state.batchId }
  );

  stepPointer(which, 1);
}

// DOM helpers / Tabs
function el(tag, props={}, children=[]){
  const node = document.createElement(tag);
  Object.entries(props).forEach(([k,v])=>{
    if(k==="class") node.className = v;
    else if(k==="html") node.innerHTML = v;
    else if(k.startsWith("on") && typeof v === "function") node.addEventListener(k.slice(2), v);
    else node.setAttribute(k,v);
  });
  (Array.isArray(children)?children:[children]).forEach(ch=>{
    if(ch === null || ch === undefined) return;
    node.appendChild(typeof ch === "string" ? document.createTextNode(ch) : ch);
  });
  return node;
}

let currentTab = "roster";
function setTab(tab){
  currentTab = tab;
  document.getElementById("tabRoster").classList.toggle("primary", tab==="roster");
  document.getElementById("tabFixed").classList.toggle("primary", tab==="fixed");
  document.getElementById("tabLoot").classList.toggle("primary", tab==="loot");
  document.getElementById("tabLogs").classList.toggle("primary", tab==="logs");
  render();
}
document.getElementById("tabRoster").onclick = () => setTab("roster");
document.getElementById("tabFixed").onclick  = () => setTab("fixed");
document.getElementById("tabLoot").onclick   = () => setTab("loot");
document.getElementById("tabLogs").onclick   = () => setTab("logs");

function render(){
  const view = document.getElementById("view");
  view.innerHTML = "";
  view.appendChild(currentView());
}
function currentView(){
  if(currentTab==="roster") return viewRoster();
  if(currentTab==="fixed")  return viewFixed();
  if(currentTab==="loot")   return viewLoot();
  return viewLogs();
}

// View: Roster + Loot catalog
function viewRoster(){
  const wrap = el("div");

  const fixedOn = laneCount("fixed");
  const lootOn  = laneCount("loot");

  const nameInput = el("input", { placeholder:"이름 입력" });
  const addBtn = el("button", { class:"primary", onclick:()=>{
    const name = nameInput.value.trim();
    if(!name) return;
    addPlayer(name);
    logEvent("ROSTER_ADD", "(명단)", null, `단일 추가: ${name}`);
    nameInput.value = "";
    render();
  }}, "추가");

  const bulkInput = el("textarea", {
    placeholder: "여러 명 붙여넣기 (한 줄에 한 명)\n예)\n혜붕\n우기\n순심이\n목성",
    rows: "6"
  });

  const bulkAddBtn = el("button", { class:"primary", onclick:()=>{
    addPlayersBulk(bulkInput.value);
    bulkInput.value = "";
    render();
  }}, "여러명 추가");

  const todayBothBtn = el("button", { class:"primary", onclick:()=>{
    setBothLanesFromNames(bulkInput.value);
    bulkInput.value = "";
    render();
  }}, "오늘 참여자만 ON(둘다)");

  const todayFixedBtn = el("button", { onclick:()=>{
    setTodayParticipantsForLane("fixed", bulkInput.value);
    bulkInput.value = "";
    render();
  }}, "오늘 참여자만 ON(고정)");

  const todayLootBtn = el("button", { onclick:()=>{
    setTodayParticipantsForLane("loot", bulkInput.value);
    bulkInput.value = "";
    render();
  }}, "오늘 참여자만 ON(전리)");

  const allOnFixedBtn = el("button", { onclick:()=>{ setAllForLane("fixed", true); render(); }}, "고정 전체 ON");
  const allOffFixedBtn = el("button", { onclick:()=>{ setAllForLane("fixed", false); render(); }}, "고정 전체 OFF");
  const allOnLootBtn = el("button", { onclick:()=>{ setAllForLane("loot", true); render(); }}, "전리 전체 ON");
  const allOffLootBtn = el("button", { onclick:()=>{ setAllForLane("loot", false); render(); }}, "전리 전체 OFF");

  const resetPtrBtn = el("button", { onclick:()=>{ resetPointers(); render(); }}, "포인터 1번 리셋");
  const batchBtn = el("button", { class:"primary", onclick:()=>{ startBatch(); render(); }}, "이번 보스 시작(배치)");

  const rosterUrlInput = el("input", {
    id:"rosterUrl",
    style:"width:min(860px,100%);",
    placeholder:"roster.txt URL (raw 권장 / github.com/blob/...도 자동 변환)",
    value:"roster.txt"
  });
  const loadRosterBtn = el("button", { class:"primary", onclick: async()=>{
    await fetchRosterFromUrl(rosterUrlInput.value);
    render();
  }}, "roster.txt 불러와서 덮어쓰기");
  const downloadRosterBtn = el("button", { onclick: exportRosterTxt }, "현재 명단 roster.txt 다운로드");

  const dangerToggle = el("input", { type:"checkbox" });
  dangerToggle.checked = !!state.ui.showDangerButtons;
  dangerToggle.addEventListener("change", ()=>{
    state.ui.showDangerButtons = dangerToggle.checked;
    saveState();
    render();
  });

  wrap.appendChild(el("div", { class:"card" }, [
    el("div", { class:"row" }, [
      el("div", { class:"pill" }, `전체 ${state.players.length}명 (최대 50)`),
      el("div", { class:"pill" }, `고정 ON ${fixedOn}명`),
      el("div", { class:"pill" }, `전리 ON ${lootOn}명`),
      el("div", { class:"pill" }, `배치 수령(고정) ${batchSummary("fixed")}명`),
      el("div", { class:"pill" }, `배치 수령(전리) ${batchSummary("loot")}명`),
    ]),
    el("div", { class:"row", style:"margin-top:10px" }, [nameInput, addBtn, resetPtrBtn, batchBtn]),
    el("div", { class:"hr" }),
    el("div", { class:"muted small" }, "GitHub에 roster.txt를 올려두면 여기서 바로 불러올 수 있습니다."),
    el("div", { class:"row", style:"margin-top:10px" }, [rosterUrlInput]),
    el("div", { class:"row", style:"margin-top:10px" }, [loadRosterBtn, downloadRosterBtn]),
    el("div", { class:"hr" }),
    el("div", { class:"row" }, [bulkInput]),
    el("div", { class:"row", style:"margin-top:10px" }, [
      bulkAddBtn, todayBothBtn, todayFixedBtn, todayLootBtn
    ]),
    el("div", { class:"row", style:"margin-top:10px" }, [
      allOnFixedBtn, allOffFixedBtn, allOnLootBtn, allOffLootBtn,
      el("div", { class:"muted small" }, "줄바꿈/쉼표/탭 구분 · 중복 자동 스킵")
    ]),
    el("details", {}, [
      el("summary", {}, "고급 옵션"),
      el("div", { class:"row", style:"margin-top:10px" }, [
        el("label", { class:"row" }, [
          dangerToggle,
          el("span", { class:"muted" }, "삭제/토큰 수동 조정 버튼 표시(주의)")
        ])
      ])
    ]),
    el("div", { class:"muted small", style:"margin-top:8px" }, "✅ 명단 순서 변경: 행을 드래그(↕)하거나 ▲/▼ 버튼을 눌러 이동")
  ]));

  // Players table
  const table = el("table");
  table.appendChild(el("thead", {}, el("tr", {}, [
    el("th", {}, "순서"),
    el("th", {}, "이름"),
    el("th", {}, "고정 ON"),
    el("th", {}, "전리 ON"),
    el("th", {}, "고정/전리 수령"),
    el("th", {}, "토큰"),
    el("th", {}, "배치(고정)"),
    el("th", {}, "배치(전리)"),
    el("th", {}, "관리"),
  ])));

  const tbody = el("tbody");
  state.players.forEach((p, idx)=>{
    const fixedBtn = el("button", { onclick:()=>{
      p.activeFixed = !p.activeFixed;
      clampPointer("fixed");
      logEvent("ROSTER_TOGGLE_LANE", "(명단)", null, `${p.name} 고정 ${p.activeFixed?"ON":"OFF"}`, { which:"fixed" });
      saveState(); render();
    }}, p.activeFixed ? "ON" : "OFF");

    const lootBtn = el("button", { onclick:()=>{
      p.activeLoot = !p.activeLoot;
      clampPointer("loot");
      logEvent("ROSTER_TOGGLE_LANE", "(명단)", null, `${p.name} 전리 ${p.activeLoot?"ON":"OFF"}`, { which:"loot" });
      saveState(); render();
    }}, p.activeLoot ? "ON" : "OFF");

    const receivedFixed = canReceive("fixed", p.id) ? el("span", { class:"muted" }, "미수령") : el("span", { class:"warn" }, "수령함");
    const receivedLoot  = canReceive("loot", p.id)  ? el("span", { class:"muted" }, "미수령") : el("span", { class:"warn" }, "수령함");

    const manage = [];
    if(state.ui.showDangerButtons){
      manage.push(
        el("button", { onclick:()=>{ p.tokens += 1; logEvent("TOKEN_ADJUST","(수동)",p.id,`${p.name} 토큰 +1`,{delta:+1}); saveState(); render(); }}, "+토큰"),
        el("button", { onclick:()=>{ if(p.tokens<=0) return; p.tokens -= 1; logEvent("TOKEN_ADJUST","(수동)",p.id,`${p.name} 토큰 -1`,{delta:-1}); saveState(); render(); }}, "-토큰"),
        el("button", { class:"danger", onclick:()=>{
          if(!confirm("삭제할까요? (되돌리기 어려움)")) return;
          state.players = state.players.filter(x=>x.id !== p.id);
          delete state.batchReceivedFixed[p.id];
          delete state.batchReceivedLoot[p.id];
          logEvent("ROSTER_DELETE","(명단)",null,`삭제: ${p.name}`);
          saveState(); render();
        }}, "삭제")
      );
    }else{
      manage.push(el("span", { class:"muted small" }, "토글로 운영"));
    }

    const tr = el("tr", {}, [
      el("td", {}, el("div", { class:"row" }, [
        el("span", { class:"drag-handle", title:"드래그로 순서 변경" }, "↕"),
        el("span", { class:"muted small" }, String(idx+1)),
        el("button", { title:"위로", onclick:()=>{ reorderPlayersByIndex(idx, -1); render(); }}, "▲"),
        el("button", { title:"아래로", onclick:()=>{ reorderPlayersByIndex(idx, 1); render(); }}, "▼"),
      ])),
      el("td", {}, p.name),
      el("td", {}, fixedBtn),
      el("td", {}, lootBtn),
      el("td", {}, `${p.fixedCount} / ${p.lootCount}`),
      el("td", {}, String(p.tokens)),
      el("td", {}, receivedFixed),
      el("td", {}, receivedLoot),
      el("td", {}, el("div", { class:"row" }, manage)),
    ]);

    // Drag & Drop reorder
    tr.draggable = true;
    tr.addEventListener("dragstart", ()=>{ _dragPlayerId = p.id; });
    tr.addEventListener("dragend", ()=>{ _dragPlayerId = null; });
    tr.addEventListener("dragover", (e)=>{ e.preventDefault(); tr.classList.add("drag-over"); });
    tr.addEventListener("dragleave", ()=>{ tr.classList.remove("drag-over"); });
    tr.addEventListener("drop", (e)=>{ e.preventDefault(); tr.classList.remove("drag-over"); reorderPlayersById(_dragPlayerId, p.id); render(); });

    tbody.appendChild(tr);
  });
  table.appendChild(tbody);

  wrap.appendChild(el("div", { class:"card" }, [
    el("h3", {}, "명단 (레인별 ON/OFF + 순서 변경)"),
    table
  ]));

  // Loot catalog section
  const catalogText = el("textarea", { rows:"8", placeholder:"전리템 아이템명 목록 (한 줄에 하나)\n예)\n도감\n희귀 장비\n강화석\n# 주석 가능" });
  catalogText.value = (state.lootCatalog || []).join("\n");

  const saveCatalogBtn = el("button", { class:"primary", onclick:()=>{
    setLootCatalogFromText(catalogText.value);
    render();
  }}, "전리템 목록 저장");

  const downloadCatalogBtn = el("button", { onclick: exportLootCatalogTxt }, "전리템 목록 loot_items.txt 다운로드");

  wrap.appendChild(el("div", { class:"card" }, [
    el("h3", {}, "전리템 목록(선택용) 관리"),
    
el("div", { class:"muted small" }, "GitHub에 loot_items.txt를 올려두면 여기서 바로 불러올 수 있습니다. (raw URL 권장)"),
(()=>{ 
  const lootUrlInput = el("input", {
    id:"lootItemsUrl",
    style:"width:min(860px,100%);",
    placeholder:"loot_items.txt URL (raw 권장 / github.com/blob/...도 자동 변환)",
    value:"loot_items.txt"
  });
  const loadLootBtn = el("button", { class:"primary", onclick: async()=>{
    await fetchLootItemsFromUrl(lootUrlInput.value);
    render();
  }}, "loot_items.txt 불러와서 덮어쓰기");
  return el("div", { class:"row", style:"margin-top:10px" }, [lootUrlInput, loadLootBtn]);
})(),
el("div", { class:"muted small" }, "전리템 레인에서 목록을 선택해 입력을 빠르게 할 수 있습니다."),
    el("div", { class:"row", style:"margin-top:10px" }, [catalogText]),
    el("div", { class:"row", style:"margin-top:10px" }, [saveCatalogBtn, downloadCatalogBtn]),
  ]));

  return wrap;
}

// View: Fixed Lane
function viewFixed(){
  const wrap = el("div");

  const peek = peekEligibleCurrent("fixed");
  const curDisplay = peek.player ? peek.player.name : "-";
  const n = laneCount("fixed");

  const itemNameInput = el("input", { value: state.fixedItemName, placeholder:"예: 고정 보상 상자" });
  itemNameInput.addEventListener("input", ()=>{
    state.fixedItemName = itemNameInput.value.trim() || "고정템";
    saveState();
  });

  const startSel = el("select");
  startSel.appendChild(el("option", { value:"" }, "포인터 시작 인원 선택(고정 ON 기준)"));
  lanePlayers("fixed").forEach(p => startSel.appendChild(el("option", { value:p.name }, p.name)));

  const setStartBtn = el("button", { onclick:()=>{
    if(!startSel.value) return alert("시작할 인원을 선택하세요.");
    setPointerToName("fixed", startSel.value);
    render();
  }}, "이 사람부터 시작");

  const batchBtn = el("button", { class:"primary", onclick:()=>{ startBatch(); render(); }}, "이번 보스 시작(배치)");

  wrap.appendChild(el("div", { class:"card" }, [
    el("h3", {}, "고정템 레인"),
    el("div", { class:"row" }, [
      el("div", { class:"pill" }, `고정 ON ${n}명`),
      el("div", { class:"pill" }, `현재(eligible): ${curDisplay}`),
      el("div", { class:"pill" }, `포인터: ${n ? (pointerValue("fixed")+1) : 0}`),
      el("div", { class:"pill" }, `배치 수령(고정) ${batchSummary("fixed")}명`),
      batchBtn
    ]),
    peek.offset>0 ? el("div", { class:"muted small warn", style:"margin-top:8px" }, `※ 이번 배치(고정 레인)에서 이미 받은 사람 ${peek.offset}명은 자동 스킵됩니다.`) : null,
    el("div", { class:"row", style:"margin-top:10px" }, [
      el("span", { class:"muted" }, "고정템 이름: "),
      itemNameInput
    ]),
    el("div", { class:"row", style:"margin-top:10px" }, [startSel, setStartBtn]),
    el("div", { class:"muted small", style:"margin-top:8px" },
      "규칙: 보스 1회(배치)에서 고정템은 1인 1개. 이미 받은 사람은 자동 스킵. 우선권도 배치 미수령자만 가능."
    )
  ]));

  const giveBtn = el("button", { class:"primary", onclick:()=>{
    if(!normalizePointerToEligible("fixed")) return;
    const cur = getCurrentEligible("fixed");
    if(!cur) return;
    cur.fixedCount += 1;
    state.fixedItemName = itemNameInput.value.trim() || "고정템";
    markReceived("fixed", cur.id);
    logEvent("FIXED_GIVE", state.fixedItemName, cur.id, `${cur.name}에게 고정템 지급`, { which:"fixed", curId:cur.id, batchId: state.batchId });
    stepPointer("fixed", 1);
    render();
  }}, "본인 수령(지급)");

  const skipBtn = el("button", { onclick:()=>{
    if(!normalizePointerToEligible("fixed")) return;
    const cur = getCurrentEligible("fixed");
    if(!cur) return;
    state.fixedItemName = itemNameInput.value.trim() || "고정템";
    logEvent("FIXED_SKIP", state.fixedItemName, cur.id, `${cur.name} 차례 스킵`, { which:"fixed", curId:cur.id, batchId: state.batchId });
    stepPointer("fixed", 1);
    render();
  }}, "스킵");

  const sel = prioritySelector("fixed", (peek.player && peek.player.id) ? peek.player.id : "");
  const priorityBtn = el("button", { onclick:()=>{
    if(!sel.value) return alert("우선권 요청자를 선택하세요.");
    priorityGive("fixed", itemNameInput.value, sel.value);
    render();
  }}, "우선권 적용(토큰1 이동)");

  wrap.appendChild(el("div", { class:"card" }, [
    el("div", { class:"row" }, [giveBtn, skipBtn]),
    el("div", { class:"hr" }),
    el("div", { class:"row" }, [
      el("span", { class:"muted" }, "우선권: "),
      sel, priorityBtn
    ])
  ]));

  return wrap;
}

// View: Loot Lane
function viewLoot(){
  const wrap = el("div");

  const peek = peekEligibleCurrent("loot");
  const curDisplay = peek.player ? peek.player.name : "-";
  const n = laneCount("loot");

  const itemInput = el("input", { placeholder:"드랍된 전리템 이름 (직접 입력)" });

  const catSel = el("select");
  catSel.appendChild(el("option", { value:"" }, (state.lootCatalog||[]).length ? "전리템 목록에서 선택" : "전리템 목록 없음(명단 탭에서 등록)"));
  (state.lootCatalog || []).forEach(x => catSel.appendChild(el("option", { value:x }, x)));
  catSel.addEventListener("change", ()=>{ if(catSel.value) itemInput.value = catSel.value; });

  const startSel = el("select");
  startSel.appendChild(el("option", { value:"" }, "포인터 시작 인원 선택(전리 ON 기준)"));
  lanePlayers("loot").forEach(p => startSel.appendChild(el("option", { value:p.name }, p.name)));

  const setStartBtn = el("button", { onclick:()=>{
    if(!startSel.value) return alert("시작할 인원을 선택하세요.");
    setPointerToName("loot", startSel.value);
    render();
  }}, "이 사람부터 시작");

  const batchBtn = el("button", { class:"primary", onclick:()=>{ startBatch(); render(); }}, "이번 보스 시작(배치)");

  wrap.appendChild(el("div", { class:"card" }, [
    el("h3", {}, "전리템 레인"),
    el("div", { class:"row" }, [
      el("div", { class:"pill" }, `전리 ON ${n}명`),
      el("div", { class:"pill" }, `현재(eligible): ${curDisplay}`),
      el("div", { class:"pill" }, `포인터: ${n ? (pointerValue("loot")+1) : 0}`),
      el("div", { class:"pill" }, `배치 수령(전리) ${batchSummary("loot")}명`),
      batchBtn
    ]),
    peek.offset>0 ? el("div", { class:"muted small warn", style:"margin-top:8px" }, `※ 이번 배치(전리 레인)에서 이미 받은 사람 ${peek.offset}명은 자동 스킵됩니다.`) : null,
    el("div", { class:"row", style:"margin-top:10px" }, [catSel]),
    el("div", { class:"row", style:"margin-top:10px" }, [itemInput]),
    el("div", { class:"row", style:"margin-top:10px" }, [startSel, setStartBtn]),
    el("div", { class:"muted small", style:"margin-top:8px" },
      "토큰 생성: 전리템 차례에서 '패스(토큰+1)'을 누르면 토큰이 새로 생성됩니다. 단, 전리 레인에서 이미 받은 사람은 자동 스킵되어 토큰 파밍이 불가합니다."
    )
  ]));

  const giveBtn = el("button", { class:"primary", onclick:()=>{
    if(!normalizePointerToEligible("loot")) return;
    const cur = getCurrentEligible("loot");
    if(!cur) return;
    const itemName = safeText(itemInput.value);
    if(itemName === "(미입력)") return alert("전리템 이름을 입력/선택하세요.");
    cur.lootCount += 1;
    markReceived("loot", cur.id);
    logEvent("LOOT_GIVE", itemName, cur.id, `${cur.name}에게 전리템 지급`, { which:"loot", curId:cur.id, batchId: state.batchId });
    stepPointer("loot", 1);
    itemInput.value = "";
    catSel.value = "";
    render();
  }}, "본인 수령(지급)");

  const passTokenBtn = el("button", { onclick:()=>{
    if(!normalizePointerToEligible("loot")) return;
    const cur = getCurrentEligible("loot");
    if(!cur) return;
    const itemName = safeText(itemInput.value);
    cur.tokens += 1;
    logEvent("LOOT_PASS_TOKEN", itemName, cur.id, `${cur.name} 전리템 패스 → 토큰 +1 생성`, { which:"loot", curId:cur.id, minted:1, batchId: state.batchId });
    stepPointer("loot", 1);
    itemInput.value = "";
    catSel.value = "";
    render();
  }}, "패스(토큰+1)");

  const skipBtn = el("button", { onclick:()=>{
    if(!normalizePointerToEligible("loot")) return;
    const cur = getCurrentEligible("loot");
    if(!cur) return;
    const itemName = safeText(itemInput.value);
    logEvent("LOOT_SKIP", itemName, cur.id, `${cur.name} 전리템 스킵(토큰 없음)`, { which:"loot", curId:cur.id, batchId: state.batchId });
    stepPointer("loot", 1);
    itemInput.value = "";
    catSel.value = "";
    render();
  }}, "스킵");

  const sel = prioritySelector("loot", (peek.player && peek.player.id) ? peek.player.id : "");
  const priorityBtn = el("button", { onclick:()=>{
    if(!sel.value) return alert("우선권 요청자를 선택하세요.");
    priorityGive("loot", itemInput.value, sel.value);
    itemInput.value = "";
    catSel.value = "";
    render();
  }}, "우선권 적용(토큰1 이동)");

  wrap.appendChild(el("div", { class:"card" }, [
    el("div", { class:"row" }, [giveBtn, passTokenBtn, skipBtn]),
    el("div", { class:"hr" }),
    el("div", { class:"row" }, [
      el("span", { class:"muted" }, "우선권: "),
      sel, priorityBtn
    ])
  ]));

  return wrap;
}

// Logs / Backup
function viewLogs(){
  const wrap = el("div");

  const exportBtn = el("button", { onclick:exportJson }, "JSON 내보내기");
  const importBtn = el("button", { onclick:importJson }, "JSON 가져오기");
  const resetBtn  = el("button", { class:"danger", onclick:resetAll }, "전체 초기화");

  wrap.appendChild(el("div", { class:"card" }, [
    el("h3", {}, "이력 / 백업"),
    el("div", { class:"row" }, [exportBtn, importBtn, resetBtn]),
    el("div", { class:"muted small", style:"margin-top:8px" },
      "팁: 다른 PC에서 쓰려면 JSON 내보내기/가져오기로 상태를 옮기면 됩니다."
    )
  ]));

  const table = el("table");
  table.appendChild(el("thead", {}, el("tr", {}, [
    el("th", {}, "시간"),
    el("th", {}, "유형"),
    el("th", {}, "아이템"),
    el("th", {}, "수령자"),
    el("th", {}, "내용"),
  ])));

  const tbody = el("tbody");
  state.logs.slice(0, 500).forEach(l=>{
    const receiver = l.receiverId ? (state.players.find(p=>p.id===l.receiverId) || null) : null;
    tbody.appendChild(el("tr", {}, [
      el("td", {}, fmt(l.ts)),
      el("td", {}, l.type),
      el("td", {}, l.itemName || ""),
      el("td", {}, receiver ? receiver.name : "-"),
      el("td", {}, l.detail || ""),
    ]));
  });
  table.appendChild(tbody);

  wrap.appendChild(el("div", { class:"card" }, [
    el("div", { class:"muted" }, `총 로그 ${state.logs.length}건 (최근 500건 표시)`),
    table
  ]));

  wrap.appendChild(el("div", { class:"card" }, [
    el("h4", {}, "규칙 요약"),
    el("div", { class:"small" }, [
      el("div", {}, "• 보스 1회(배치)에서: 고정템 1인1개 / 전리템 1인1개 (레인별 별도)"),
      el("div", {}, "• 이미 받은 사람은 해당 레인에서 자동 스킵"),
      el("div", {}, "• 우선권(토큰 1개): 요청자 -1 / 원차례자 +1 / 아이템은 요청자 / 단, 요청자는 해당 레인 배치 미수령자"),
      el("div", {}, "• 전리 패스(토큰+1): 전리 레인 배치 미수령자만 가능(자동 스킵으로 토큰 파밍 방지)"),
      el("div", {}, "• 명단은 레인별 ON/OFF로 따로 운영"),
      el("div", {}, "• 명단 순서는 드래그/▲▼로 임의 수정 가능")
    ])
  ]));

  return wrap;
}

// Backup / Reset
function exportJson(){
  const blob = new Blob([JSON.stringify(state, null, 2)], { type:"application/json" });
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = `loot_state_${Date.now()}.json`;
  a.click();
  URL.revokeObjectURL(url);
}
function importJson(){
  const inp = document.createElement("input");
  inp.type = "file";
  inp.accept = "application/json";
  inp.onchange = () => {
    const file = inp.files && inp.files[0];
    if(!file) return;
    const reader = new FileReader();
    reader.onload = () => {
      try{
        const parsed = JSON.parse(String(reader.result));
        state = {
          ...defaultState(),
          ...parsed,
          ui: { ...defaultState().ui, ...(parsed.ui||{}) },
          batchReceivedFixed: parsed.batchReceivedFixed || {},
          batchReceivedLoot: parsed.batchReceivedLoot || {}
        };
        logEvent("IMPORT", "(백업)", null, "JSON 가져오기 완료");
        saveState();
        render();
      }catch(e){
        alert("JSON 파싱 실패");
      }
    };
    reader.readAsText(file);
  };
  inp.click();
}
function resetAll(){
  if(!confirm("정말 전체 초기화할까요?")) return;
  state = defaultState();
  saveState();
  render();
}

// Init
setTab("roster");
if(state.batchId === null) startBatch();
</script>
</body>
</html>
