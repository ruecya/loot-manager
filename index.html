<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ì „ë¦¬í’ˆ ë¶„ë°° ë§¤ë‹ˆì € v6 (UI ê°œì„ íŒ)</title>
  <style>
    :root {
      --primary: #4f46e5;
      --primary-hover: #4338ca;
      --danger: #ef4444;
      --danger-hover: #dc2626;
      --success: #10b981;
      --bg: #f3f4f6;
      --card-bg: #ffffff;
      --text-main: #1f2937;
      --text-muted: #6b7280;
      --border: #e5e7eb;
      --radius: 8px;
      --shadow: 0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1);
    }

    * { box-sizing: border-box; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
      background-color: var(--bg);
      color: var(--text-main);
      margin: 0;
      padding: 0;
      line-height: 1.5;
    }

    /* Layout */
    .container {
      max-width: 1000px;
      margin: 0 auto;
      padding: 16px;
    }

    /* Navigation / Tabs */
    .nav-tabs {
      display: flex;
      gap: 8px;
      background: var(--card-bg);
      padding: 8px;
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      margin-bottom: 20px;
      overflow-x: auto;
    }
    .nav-btn {
      flex: 1;
      padding: 10px 16px;
      border: none;
      background: transparent;
      color: var(--text-muted);
      font-weight: 600;
      cursor: pointer;
      border-radius: 6px;
      transition: all 0.2s;
      white-space: nowrap;
      text-align: center;
    }
    .nav-btn:hover { background: var(--bg); color: var(--text-main); }
    .nav-btn.active {
      background: var(--primary);
      color: white;
      box-shadow: 0 2px 4px rgba(79, 70, 229, 0.3);
    }

    /* Cards */
    .card {
      background: var(--card-bg);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding: 20px;
      margin-bottom: 20px;
      border: 1px solid var(--border);
    }
    .card h3 { margin-top: 0; margin-bottom: 16px; font-size: 1.25rem; color: var(--text-main); border-bottom: 1px solid var(--border); padding-bottom: 10px; }
    .card h4 { margin: 16px 0 8px 0; font-size: 1rem; }

    /* Forms & Inputs */
    .row { display: flex; gap: 10px; flex-wrap: wrap; align-items: center; }
    .col { display: flex; flex-direction: column; gap: 8px; }
    
    input, select, textarea {
      padding: 10px 12px;
      border: 1px solid var(--border);
      border-radius: 6px;
      font-size: 0.95rem;
      width: 100%;
      transition: border-color 0.2s;
    }
    input:focus, select:focus, textarea:focus {
      outline: none;
      border-color: var(--primary);
      box-shadow: 0 0 0 3px rgba(79, 70, 229, 0.1);
    }

    /* Buttons */
    button {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 10px 16px;
      border-radius: 6px;
      border: 1px solid var(--border);
      background: white;
      color: var(--text-main);
      font-weight: 500;
      cursor: pointer;
      font-size: 0.9rem;
      transition: all 0.2s;
    }
    button:hover { background: #f9fafb; border-color: #d1d5db; }
    button:active { transform: translateY(1px); }

    button.primary {
      background: var(--primary);
      border-color: var(--primary);
      color: white;
    }
    button.primary:hover { background: var(--primary-hover); }

    button.danger {
      background: white;
      color: var(--danger);
      border-color: var(--danger);
    }
    button.danger:hover { background: #fef2f2; }
    
    button.success {
      background: var(--success);
      border-color: var(--success);
      color: white;
    }

    button.sm { padding: 4px 8px; font-size: 0.8rem; }

    /* Tables */
    .table-responsive { overflow-x: auto; }
    table { width: 100%; border-collapse: collapse; font-size: 0.9rem; }
    th {
      background: #f9fafb;
      text-align: left;
      padding: 12px;
      font-weight: 600;
      color: var(--text-muted);
      border-bottom: 2px solid var(--border);
      white-space: nowrap;
    }
    td {
      padding: 12px;
      border-bottom: 1px solid var(--border);
      vertical-align: middle;
    }
    tr:last-child td { border-bottom: none; }
    tr:hover td { background: #f9fafb; }
    
    /* Drag & Drop */
    .drag-handle { cursor: grab; color: var(--text-muted); font-size: 1.2rem; padding-right: 8px; }
    tr.drag-over td { background: #eef2ff; border-top: 2px dashed var(--primary); }

    /* Utilities */
    .muted { color: var(--text-muted); font-size: 0.85rem; }
    .warn { color: #d97706; font-weight: 600; }
    .text-danger { color: var(--danger); }
    .pill {
      display: inline-flex;
      padding: 4px 12px;
      background: #eef2ff;
      color: var(--primary);
      border-radius: 999px;
      font-size: 0.8rem;
      font-weight: 600;
      border: 1px solid #c7d2fe;
    }
    .badge {
      display: inline-block;
      padding: 2px 8px;
      border-radius: 4px;
      font-size: 0.75rem;
      font-weight: 600;
    }
    .badge.on { background: #d1fae5; color: #065f46; }
    .badge.off { background: #f3f4f6; color: #6b7280; }
    .badge.done { background: #fef3c7; color: #92400e; }
    .badge.ready { background: #e0e7ff; color: #3730a3; }

    .hr { height: 1px; background: var(--border); margin: 16px 0; }
    .flex-center { display: flex; align-items: center; justify-content: center; }
    
    /* Current Player Highlight */
    .current-player-box {
      background: #e0e7ff;
      border: 1px solid #c7d2fe;
      padding: 16px;
      border-radius: var(--radius);
      text-align: center;
      margin-bottom: 16px;
    }
    .current-player-name {
      font-size: 1.5rem;
      font-weight: 700;
      color: var(--primary);
      display: block;
      margin: 8px 0;
    }

    details summary { cursor: pointer; color: var(--primary); font-weight: 600; }
  </style>
</head>
<body>

<div class="container">
  <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:16px;">
    <h2 style="margin:0;">âš”ï¸ ì „ë¦¬í’ˆ ë§¤ë‹ˆì € v6</h2>
    <span class="muted">UI Improved</span>
  </div>

  <div class="nav-tabs">
    <button id="tabRoster" class="nav-btn active">ğŸ‘¥ ëª…ë‹¨/ëª©ë¡</button>
    <button id="tabFixed" class="nav-btn">ğŸ’ ê³ ì •í…œ ë ˆì¸</button>
    <button id="tabLoot" class="nav-btn">ğŸ² ì „ë¦¬í…œ ë ˆì¸</button>
    <button id="tabLogs" class="nav-btn">ğŸ“œ ì´ë ¥/ë°±ì—…</button>
  </div>

  <div id="view"></div>
</div>

<script>
/**
 * ê¸°ëŠ¥ ë¡œì§ì€ v5ì™€ ë™ì¼í•˜ê²Œ ìœ ì§€
 * UI ë Œë”ë§ ë¶€ë¶„ë§Œ ê°œì„ ëœ CSS í´ë˜ìŠ¤ì™€ êµ¬ì¡°ë¡œ ë³€ê²½
 */

const STORAGE_KEY = "loot_manager_v5";

// --- Reorder helpers (ëª…ë‹¨ ìˆœì„œ ë³€ê²½) ---
let _dragPlayerId = null;
function moveArrayItem(arr, fromIdx, toIdx){
  if(fromIdx === toIdx) return arr;
  const copy = arr.slice();
  const [it] = copy.splice(fromIdx, 1);
  copy.splice(toIdx, 0, it);
  return copy;
}
function reorderPlayersById(dragId, dropId){
  if(!dragId || !dropId || dragId===dropId) return;
  const fromIdx = state.players.findIndex(p=>p.id===dragId);
  const toIdx   = state.players.findIndex(p=>p.id===dropId);
  if(fromIdx<0 || toIdx<0) return;
  state.players = moveArrayItem(state.players, fromIdx, toIdx);
  logEvent("ROSTER_REORDER","(ëª…ë‹¨)", null, `ëª…ë‹¨ ìˆœì„œ ë³€ê²½: ${fromIdx+1} â†’ ${toIdx+1}`, { fromIdx, toIdx, dragId, dropId });
  saveState();
}
function reorderPlayersByIndex(i, delta){
  const j = i + delta;
  if(i<0 || j<0 || i>=state.players.length || j>=state.players.length) return;
  state.players = moveArrayItem(state.players, i, j);
  logEvent("ROSTER_REORDER","(ëª…ë‹¨)", null, `ëª…ë‹¨ ìˆœì„œ ë³€ê²½: ${i+1} â†” ${j+1}`, { fromIdx:i, toIdx:j });
  saveState();
}

// Utils
function nowTs(){ return Date.now(); }
function fmt(ts){
  const d = new Date(ts);
  const pad = n => String(n).padStart(2,"0");
  return `${d.getFullYear()}-${pad(d.getMonth()+1)}-${pad(d.getDate())} ${pad(d.getHours())}:${pad(d.getMinutes())}:${pad(d.getSeconds())}`;
}
function safeText(s, fallback="(ë¯¸ì…ë ¥)"){
  const t = (s || "").trim();
  return t ? t : fallback;
}

function normalizeGitHubTextUrl(u){
  const url = (u || "").trim();
  if(!url) return url;
  try{
    const m = url.match(/^https:\/\/github\.com\/([^\/]+)\/([^\/]+)\/blob\/([^\/]+)\/(.+)$/);
    if(m){
      const owner = m[1], repo = m[2], branch = m[3], path = m[4];
      return `https://raw.githubusercontent.com/${owner}/${repo}/${branch}/${path}`;
    }
  }catch(e){}
  return url;
}

function looksLikeHtml(text){
  const t = (text || "").trim().slice(0, 200).toLowerCase();
  return t.includes("<!doctype html") || t.includes("<html") || t.includes("<head") || t.includes("<body");
}

function stripBom(s){
  if(!s) return s;
  return s.charCodeAt(0) === 0xFEFF ? s.slice(1) : s;
}


// State
function defaultState(){
  return {
    players: [],
    fixedPointer: 0,
    lootPointer: 0,
    fixedItemName: "ê³ ì •í…œ",
    lootCatalog: [],
    batchId: null,
    batchReceivedFixed: {},
    batchReceivedLoot: {},
    logs: [],
    ui: { showDangerButtons: false }
  };
}
let state = loadState();

function loadState(){
  try{
    const raw = localStorage.getItem(STORAGE_KEY);
    if(!raw) return defaultState();
    const parsed = JSON.parse(raw);
    return {
      ...defaultState(),
      ...parsed,
      ui: { ...defaultState().ui, ...(parsed.ui||{}) },
      batchReceivedFixed: parsed.batchReceivedFixed || {},
      batchReceivedLoot: parsed.batchReceivedLoot || {}
    };
  }catch(e){
    console.warn(e);
    return defaultState();
  }
}
function saveState(){
  localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
}
function logEvent(type, itemName, receiverId, detail, meta = {}){
  state.logs.unshift({ ts: nowTs(), type, itemName, receiverId, detail, meta });
  saveState();
}

// Batch
function startBatch(){
  state.batchId = nowTs();
  state.batchReceivedFixed = {};
  state.batchReceivedLoot = {};
  logEvent("BATCH_START", "(ë°°ì¹˜)", null, "ì´ë²ˆ ë³´ìŠ¤(ë°°ì¹˜) ì‹œì‘: ë ˆì¸ë³„ 1ì¸1ê°œ ì´ˆê¸°í™”", { batchId: state.batchId });
  saveState();
}
function canReceive(which, playerId){
  if(which === "fixed") return !state.batchReceivedFixed[playerId];
  return !state.batchReceivedLoot[playerId];
}
function markReceived(which, playerId){
  if(which === "fixed") state.batchReceivedFixed[playerId] = true;
  else state.batchReceivedLoot[playerId] = true;
  saveState();
}
function batchSummary(which){
  if(which === "fixed") return Object.keys(state.batchReceivedFixed || {}).length;
  if(which === "loot") return Object.keys(state.batchReceivedLoot || {}).length;
  return (Object.keys(state.batchReceivedFixed || {}).length + Object.keys(state.batchReceivedLoot || {}).length);
}

// Lane roster / pointer
function laneKey(which){ return which === "fixed" ? "activeFixed" : "activeLoot"; }
function lanePlayers(which){
  const key = laneKey(which);
  return state.players.filter(p => !!p[key]);
}
function laneCount(which){ return lanePlayers(which).length; }

function clampPointer(which){
  const n = laneCount(which);
  if(n === 0){
    if(which==="fixed") state.fixedPointer = 0;
    else state.lootPointer = 0;
    return;
  }
  if(which==="fixed") state.fixedPointer = ((state.fixedPointer % n) + n) % n;
  else state.lootPointer = ((state.lootPointer % n) + n) % n;
}
function pointerValue(which){
  clampPointer(which);
  return which==="fixed" ? state.fixedPointer : state.lootPointer;
}
function setPointerValue(which, v){
  if(which==="fixed") state.fixedPointer = v;
  else state.lootPointer = v;
  clampPointer(which);
  saveState();
}
function stepPointer(which, step=1){
  const n = laneCount(which);
  if(n === 0) return;
  const p = pointerValue(which);
  setPointerValue(which, (p + step) % n);
}
function peekEligibleCurrent(which){
  const arr = lanePlayers(which);
  const n = arr.length;
  if(n === 0) return { player:null, offset:0, exhausted:true };

  const start = pointerValue(which);
  for(let i=0; i<n; i++){
    const idx = (start + i) % n;
    const p = arr[idx];
    if(canReceive(which, p.id)){
      return { player:p, offset:i, exhausted:false };
    }
  }
  return { player:null, offset:0, exhausted:true };
}
function normalizePointerToEligible(which){
  const n = laneCount(which);
  if(n === 0){
    alert("í•´ë‹¹ ë ˆì¸ ì°¸ì—¬ìê°€ ì—†ìŠµë‹ˆë‹¤. (ëª…ë‹¨ì—ì„œ ON ì„¤ì •)");
    return false;
  }
  const peek = peekEligibleCurrent(which);
  if(peek.exhausted){
    alert("ì´ë²ˆ ë°°ì¹˜ì—ì„œ ë°›ì„ ì‚¬ëŒì´ ì—†ìŠµë‹ˆë‹¤. ìƒˆ ë³´ìŠ¤ë©´ [ì´ë²ˆ ë³´ìŠ¤ ì‹œì‘]ì„ ëˆŒëŸ¬ì£¼ì„¸ìš”.");
    return false;
  }
  if(peek.offset > 0){
    stepPointer(which, peek.offset);
    logEvent("AUTO_SKIP_BATCH", "(ìë™)", null,
      `${which==="fixed"?"ê³ ì •":"ì „ë¦¬"} ë ˆì¸: ë ˆì¸ë³„ 1ì¸1ê°œë¡œ ${peek.offset}ëª… ìë™ ìŠ¤í‚µ`,
      { which, skipped: peek.offset, batchId: state.batchId }
    );
  }
  return true;
}
function getCurrentEligible(which){
  const arr = lanePlayers(which);
  if(arr.length === 0) return null;
  const idx = pointerValue(which);
  return arr[idx] || null;
}

// Player ops
function addPlayer(name){
  if(state.players.length >= 50) return alert("ìµœëŒ€ 50ëª…ê¹Œì§€ ê°€ëŠ¥í•©ë‹ˆë‹¤.");
  const id = crypto.randomUUID ? crypto.randomUUID() : String(Math.random()).slice(2);
  state.players.push({
    id,
    name,
    activeFixed: true,
    activeLoot: true,
    fixedCount: 0,
    lootCount: 0,
    tokens: 0
  });
  saveState();
}
function parseNames(text){
  return (text || "")
    .split(/[\n,|\t]+/g)
    .map(s => s.trim())
    .filter(Boolean);
}
function addPlayersBulk(text){
  const parts = parseNames(text);
  if(parts.length === 0) return;

  const existing = new Set(state.players.map(p => p.name.trim()));
  const seen = new Set();
  const unique = [];
  for(const n of parts){
    if(existing.has(n)) continue;
    if(seen.has(n)) continue;
    unique.push(n);
    seen.add(n);
  }
  if(unique.length === 0){
    alert("ì¶”ê°€í•  ìƒˆ ì¸ì›ì´ ì—†ìŠµë‹ˆë‹¤. (ì¤‘ë³µì´ê±°ë‚˜ ë¹„ì–´ìˆìŒ)");
    return;
  }
  const room = 50 - state.players.length;
  const toAdd = unique.slice(0, Math.max(0, room));
  toAdd.forEach(addPlayer);

  logEvent("ROSTER_BULK_ADD", "(ëª…ë‹¨)", null, `ëŒ€ëŸ‰ ì¶”ê°€: ${toAdd.length}ëª…`, { added: toAdd });
  if(unique.length > room){
    alert(`ìµœëŒ€ 50ëª… ì œí•œìœ¼ë¡œ ${toAdd.length}ëª…ë§Œ ì¶”ê°€í–ˆìŠµë‹ˆë‹¤. (ì´ˆê³¼ ${unique.length - room}ëª…)`);
  }
  saveState();
}
function setTodayParticipantsForLane(which, text){
  const names = parseNames(text);
  if(names.length === 0) return alert("ì´ë¦„ì„ ë¶™ì—¬ë„£ì–´ì£¼ì„¸ìš”.");
  const set = new Set(names.map(s=>s.trim()));
  const key = laneKey(which);
  state.players.forEach(p => { p[key] = set.has(p.name.trim()); });
  clampPointer(which);
  logEvent("ROSTER_TODAY_SET", "(ëª…ë‹¨)", null, `ì˜¤ëŠ˜ ì°¸ì—¬ìë§Œ ON (${which})`, { which, names });
  saveState();
}
function setAllForLane(which, on){
  const key = laneKey(which);
  state.players.forEach(p => p[key] = !!on);
  clampPointer(which);
  logEvent(on ? "ROSTER_ALL_ON" : "ROSTER_ALL_OFF", "(ëª…ë‹¨)", null, `${which} ì „ì²´ ${on?"ON":"OFF"}`, { which });
  saveState();
}
function setBothLanesFromNames(text){
  const names = parseNames(text);
  if(names.length === 0) return alert("ì´ë¦„ì„ ë¶™ì—¬ë„£ì–´ì£¼ì„¸ìš”.");
  const set = new Set(names.map(s=>s.trim()));
  state.players.forEach(p=>{
    const on = set.has(p.name.trim());
    p.activeFixed = on;
    p.activeLoot = on;
  });
  clampPointer("fixed"); clampPointer("loot");
  logEvent("ROSTER_TODAY_SET_BOTH", "(ëª…ë‹¨)", null, "ì˜¤ëŠ˜ ì°¸ì—¬ìë§Œ ON (ê³ ì •+ì „ë¦¬)", { names });
  saveState();
}
function resetPointers(){
  state.fixedPointer = 0;
  state.lootPointer = 0;
  clampPointer("fixed"); clampPointer("loot");
  logEvent("POINTER_RESET", "(í¬ì¸í„°)", null, "ê³ ì •/ì „ë¦¬ í¬ì¸í„°ë¥¼ 1ë²ˆìœ¼ë¡œ ë¦¬ì…‹");
  saveState();
}
function setPointerToName(which, name){
  const arr = lanePlayers(which);
  if(arr.length === 0) return alert("í•´ë‹¹ ë ˆì¸ ì°¸ì—¬ìê°€ ì—†ìŠµë‹ˆë‹¤.");
  const idx = arr.findIndex(p => p.name.trim() === name.trim());
  if(idx < 0) return alert("í•´ë‹¹ ë ˆì¸ ì°¸ì—¬ì(ON)ì—ì„œ ì´ë¦„ì„ ì°¾ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.");
  setPointerValue(which, idx);
  logEvent("POINTER_SET", "(í¬ì¸í„°)", null, `${which} í¬ì¸í„°ë¥¼ ${name}ë¶€í„° ì‹œì‘`);
  saveState();
}

// GitHub roster.txt load
function parseRosterText(text){
  return (text || "")
    .split(/\r?\n/g)
    .map(s => s.trim())
    .filter(s => s && !s.startsWith("#"));
}
async function fetchRosterFromUrl(url){
  let u = normalizeGitHubTextUrl((url || "").trim());
  if(!u) return alert("roster.txt URLì„ ì…ë ¥í•˜ì„¸ìš”.");
  try{
    const res = await fetch(u, { cache: "no-store" });
    if(!res.ok) throw new Error("HTTP " + res.status);
    let txt = stripBom(await res.text());
    if(looksLikeHtml(txt)) return alert("ë¶ˆëŸ¬ì˜¤ê¸° ì‹¤íŒ¨: GitHub raw ì£¼ì†Œê°€ ì•„ë‹Œ ê²ƒ ê°™ìŠµë‹ˆë‹¤.");
    const names = parseRosterText(txt);
    if(names.length === 0) return alert("roster.txtì—ì„œ ì´ë¦„ì„ ì°¾ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.");

    const unique = [];
    const seen = new Set();
    for(const n of names){
      if(seen.has(n)) continue;
      unique.push(n);
      seen.add(n);
    }
    const finalNames = unique.slice(0, 50);

    if(!confirm(`roster.txtì—ì„œ ${finalNames.length}ëª…ì„ ë¶ˆëŸ¬ì˜µë‹ˆë‹¤.\ní˜„ì¬ ëª…ë‹¨ì„ ë®ì–´ì“¸ê¹Œìš”?`)) return;

    state.players = [];
    state.fixedPointer = 0;
    state.lootPointer = 0;

    finalNames.forEach(addPlayer);
    state.players.forEach(p => { p.activeFixed = true; p.activeLoot = true; });

    resetPointers();
    logEvent("ROSTER_FROM_TXT", "(ëª…ë‹¨)", null, `roster.txt ë¶ˆëŸ¬ì˜¤ê¸°(ë®ì–´ì“°ê¸°): ${finalNames.length}ëª…`, { url: u, names: finalNames });
    saveState();
    alert("ëª…ë‹¨ì„ ë¶ˆëŸ¬ì™”ìŠµë‹ˆë‹¤.");
  }catch(e){
    alert("ë¶ˆëŸ¬ì˜¤ê¸° ì‹¤íŒ¨: " + (e.message || e));
  }
}
function exportRosterTxt(){
  const lines = state.players.map(p => p.name);
  const content = lines.join("\n") + "\n";
  const blob = new Blob([content], { type:"text/plain;charset=utf-8" });
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = "roster.txt";
  a.click();
  URL.revokeObjectURL(url);
}

// GitHub loot_items.txt load
function parseLootItemsText(text){
  return (text || "")
    .split(/\r?\n/g)
    .map(s => s.trim())
    .filter(s => s && !s.startsWith("#"));
}
async function fetchLootItemsFromUrl(url){
  let u = normalizeGitHubTextUrl((url || "").trim());
  if(!u) return alert("loot_items.txt URLì„ ì…ë ¥í•˜ì„¸ìš”.");
  try{
    const res = await fetch(u, { cache: "no-store" });
    if(!res.ok) throw new Error("HTTP " + res.status);
    let txt = stripBom(await res.text());
    if(looksLikeHtml(txt)) return alert("ë¶ˆëŸ¬ì˜¤ê¸° ì‹¤íŒ¨");
    const items = parseLootItemsText(txt);
    if(items.length === 0) return alert("loot_items.txtì—ì„œ ì•„ì´í…œì„ ì°¾ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.");

    const seen = new Set();
    const uniq = [];
    for(const it of items){
      if(seen.has(it)) continue;
      seen.add(it);
      uniq.push(it);
    }

    if(!confirm(`loot_items.txtì—ì„œ ${uniq.length}ê°œ ì•„ì´í…œì„ ë¶ˆëŸ¬ì˜µë‹ˆë‹¤.\ní˜„ì¬ ì „ë¦¬í…œ ëª©ë¡ì„ ë®ì–´ì“¸ê¹Œìš”?`)) return;
    state.lootCatalog = uniq;
    logEvent("LOOT_CATALOG_FROM_TXT", "(ì „ë¦¬ëª©ë¡)", null, `loot_items.txt ë¶ˆëŸ¬ì˜¤ê¸°(ë®ì–´ì“°ê¸°): ${uniq.length}ê°œ`, { url: u, items: uniq });
    saveState();
    alert(`ì „ë¦¬í’ˆ ëª©ë¡ì„ ë¶ˆëŸ¬ì™”ìŠµë‹ˆë‹¤. (${uniq.length}ê°œ)`);
  }catch(e){
    alert("ë¶ˆëŸ¬ì˜¤ê¸° ì‹¤íŒ¨: " + (e.message || e));
  }
}


// Loot catalog
function setLootCatalogFromText(text){
  const names = (text || "")
    .split(/\r?\n/g)
    .map(s=>s.trim())
    .filter(s=>s && !s.startsWith("#"));
  const seen = new Set();
  const uniq = [];
  for(const n of names){
    if(seen.has(n)) continue;
    seen.add(n);
    uniq.push(n);
  }
  state.lootCatalog = uniq;
  logEvent("LOOT_CATALOG_SET", "(ì „ë¦¬ëª©ë¡)", null, `ì „ë¦¬í…œ ëª©ë¡ ì €ì¥: ${uniq.length}ê°œ`);
  saveState();
}
function exportLootCatalogTxt(){
  const lines = (state.lootCatalog || []);
  const content = lines.join("\n") + "\n";
  const blob = new Blob([content], { type:"text/plain;charset=utf-8" });
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = "loot_items.txt";
  a.click();
  URL.revokeObjectURL(url);
}

// Priority
function prioritySelector(which, currentId){
  const sel = document.createElement("select");
  const key = laneKey(which);
  const candidates = state.players
    .filter(p => !!p[key] && p.tokens >= 1 && p.id !== currentId && canReceive(which, p.id))
    .sort((a,b)=> b.tokens - a.tokens || a.name.localeCompare(b.name));

  sel.appendChild(el("option", { value:"" }, candidates.length ? "âš ï¸ ìš°ì„ ê¶Œ ì‚¬ìš© (ëŒ€ìƒ ì„ íƒ)" : "ì‚¬ìš© ê°€ëŠ¥í•œ ëŒ€ìƒ ì—†ìŒ"));
  candidates.forEach(p=>{
    sel.appendChild(el("option", { value:p.id }, `ğŸ« ${p.name} (í† í° ${p.tokens})`));
  });
  return sel;
}
function priorityGive(which, itemName, claimantId){
  if(!normalizePointerToEligible(which)) return;
  const cur = getCurrentEligible(which);
  if(!cur) return;

  const claimant = state.players.find(p => p.id === claimantId) || null;
  if(!claimant) return alert("ìš”ì²­ìë¥¼ ì„ íƒí•˜ì„¸ìš”.");
  if(!claimant[laneKey(which)]) return alert("ìš”ì²­ìê°€ í•´ë‹¹ ë ˆì¸ì—ì„œ OFF ìƒíƒœì…ë‹ˆë‹¤.");
  if(claimant.tokens < 1) return alert("ìš”ì²­ì í† í°ì´ ë¶€ì¡±í•©ë‹ˆë‹¤. (í•„ìš”: 1)");
  if(!canReceive(which, claimant.id)) return alert("ìš”ì²­ìëŠ” ì´ë²ˆ ë°°ì¹˜ì—ì„œ ì´ë¯¸ 1ê°œë¥¼ ë°›ì•˜ìŠµë‹ˆë‹¤. (ìš°ì„ ê¶Œ ë¶ˆê°€)");
  if(claimant.id === cur.id) return alert("í˜„ì¬ ì°¨ë¡€ì ë³¸ì¸ì€ ìš°ì„ ê¶Œ ìš”ì²­ ëŒ€ìƒì´ ì•„ë‹™ë‹ˆë‹¤.");

  const finalItemName = safeText(itemName);

  // Token ì´ë™
  claimant.tokens -= 1;
  cur.tokens += 1;

  if(which === "fixed") claimant.fixedCount += 1;
  else claimant.lootCount += 1;

  markReceived(which, claimant.id);

  logEvent(
    which === "fixed" ? "PRIORITY_FIXED" : "PRIORITY_LOOT",
    finalItemName,
    claimant.id,
    `ìš°ì„ ê¶Œ ì ìš©: ì›ì°¨ë¡€ì=${cur.name} â†’ ìˆ˜ë ¹ì=${claimant.name} / í† í° 1ê°œ ${cur.name}ì—ê²Œ ì´ë™`,
    { which, curId: cur.id, claimantId: claimant.id, tokenTransfer: 1, batchId: state.batchId }
  );

  stepPointer(which, 1);
}

// DOM helpers
function el(tag, props={}, children=[]){
  const node = document.createElement(tag);
  Object.entries(props).forEach(([k,v])=>{
    if(k==="class") node.className = v;
    else if(k==="html") node.innerHTML = v;
    else if(k.startsWith("on") && typeof v === "function") node.addEventListener(k.slice(2), v);
    else node.setAttribute(k,v);
  });
  (Array.isArray(children)?children:[children]).forEach(ch=>{
    if(ch === null || ch === undefined) return;
    node.appendChild(typeof ch === "string" ? document.createTextNode(ch) : ch);
  });
  return node;
}

let currentTab = "roster";
function setTab(tab){
  currentTab = tab;
  document.getElementById("tabRoster").classList.toggle("active", tab==="roster");
  document.getElementById("tabFixed").classList.toggle("active", tab==="fixed");
  document.getElementById("tabLoot").classList.toggle("active", tab==="loot");
  document.getElementById("tabLogs").classList.toggle("active", tab==="logs");
  render();
}
document.getElementById("tabRoster").onclick = () => setTab("roster");
document.getElementById("tabFixed").onclick  = () => setTab("fixed");
document.getElementById("tabLoot").onclick   = () => setTab("loot");
document.getElementById("tabLogs").onclick   = () => setTab("logs");

function render(){
  const view = document.getElementById("view");
  view.innerHTML = "";
  view.appendChild(currentView());
}
function currentView(){
  if(currentTab==="roster") return viewRoster();
  if(currentTab==="fixed")  return viewFixed();
  if(currentTab==="loot")   return viewLoot();
  return viewLogs();
}

// View: Roster
function viewRoster(){
  const wrap = el("div");

  const fixedOn = laneCount("fixed");
  const lootOn  = laneCount("loot");

  const nameInput = el("input", { placeholder:"ì´ë¦„ ì…ë ¥", style:"flex:1;" });
  const addBtn = el("button", { class:"primary", onclick:()=>{
    const name = nameInput.value.trim();
    if(!name) return;
    addPlayer(name);
    logEvent("ROSTER_ADD", "(ëª…ë‹¨)", null, `ë‹¨ì¼ ì¶”ê°€: ${name}`);
    nameInput.value = "";
    render();
  }}, "â• ì¶”ê°€");

  const bulkInput = el("textarea", {
    placeholder: "ì—¬ëŸ¬ ëª… ë¶™ì—¬ë„£ê¸° (í•œ ì¤„ì— í•œ ëª…)\nì˜ˆ)\ní˜œë¶•\nìš°ê¸°\nìˆœì‹¬ì´\nëª©ì„±",
    rows: "5"
  });

  const rosterUrlInput = el("input", {
    id:"rosterUrl",
    placeholder:"roster.txt URL (raw ì£¼ì†Œ)",
    value:"roster.txt",
    style:"flex:2;"
  });

  const dangerToggle = el("input", { type:"checkbox", style:"width:auto; margin-right:8px;" });
  dangerToggle.checked = !!state.ui.showDangerButtons;
  dangerToggle.addEventListener("change", ()=>{
    state.ui.showDangerButtons = dangerToggle.checked;
    saveState();
    render();
  });

  // Top Stats Card
  wrap.appendChild(el("div", { class:"card" }, [
    el("div", { class:"row" }, [
      el("span", { class:"pill" }, `ì „ì²´: ${state.players.length}ëª…`),
      el("span", { class:"pill" }, `ê³ ì •ON: ${fixedOn}ëª…`),
      el("span", { class:"pill" }, `ì „ë¦¬ON: ${lootOn}ëª…`),
      el("span", { class:"pill" }, `ì™„ë£Œ(ê³ ì •): ${batchSummary("fixed")}ëª…`),
      el("span", { class:"pill" }, `ì™„ë£Œ(ì „ë¦¬): ${batchSummary("loot")}ëª…`),
    ]),
    el("div", { class:"hr" }),
    el("div", { class:"row" }, [ nameInput, addBtn ]),
    el("div", { class:"row", style:"margin-top:10px" }, [
        el("button", { class:"", onclick:()=>{ resetPointers(); render(); }}, "ğŸ”„ í¬ì¸í„° ë¦¬ì…‹"),
        el("button", { class:"primary", onclick:()=>{ startBatch(); render(); }}, "âš”ï¸ ì´ë²ˆ ë³´ìŠ¤ ì‹œì‘(ë°°ì¹˜ ì´ˆê¸°í™”)")
    ])
  ]));

  // Bulk & Settings Card
  wrap.appendChild(el("div", { class:"card" }, [
    el("details", {}, [
      el("summary", {}, "ğŸ“‚ ëŒ€ëŸ‰ ì¶”ê°€ ë° ì„¤ì •"),
      el("div", { style:"margin-top:16px;" }, [
        el("h4", {}, "í…ìŠ¤íŠ¸ ë¶™ì—¬ë„£ê¸°"),
        bulkInput,
        el("div", { class:"row", style:"margin-top:8px" }, [
          el("button", { onclick:()=>{ addPlayersBulk(bulkInput.value); bulkInput.value=""; render(); }}, "ëª…ë‹¨ ì¶”ê°€"),
          el("button", { onclick:()=>{ setBothLanesFromNames(bulkInput.value); bulkInput.value=""; render(); }}, "ì˜¤ëŠ˜ ì°¸ì—¬ìë§Œ ON (ë‘˜ë‹¤)"),
        ]),
        el("div", { class:"row", style:"margin-top:8px" }, [
          el("button", { class:"sm", onclick:()=>{ setTodayParticipantsForLane("fixed", bulkInput.value); bulkInput.value=""; render(); }}, "ê³ ì •ë§Œ ON"),
          el("button", { class:"sm", onclick:()=>{ setTodayParticipantsForLane("loot", bulkInput.value); bulkInput.value=""; render(); }}, "ì „ë¦¬ë§Œ ON"),
        ]),
        el("div", { class:"hr" }),
        el("h4", {}, "GitHub ì—°ë™"),
        el("div", { class:"row" }, [ rosterUrlInput, el("button", { onclick: async()=>{ await fetchRosterFromUrl(rosterUrlInput.value); render(); }}, "ë¶ˆëŸ¬ì˜¤ê¸°") ]),
        el("div", { class:"row", style:"margin-top:8px" }, [ el("button", { class:"sm", onclick: exportRosterTxt }, "roster.txt ë‹¤ìš´ë¡œë“œ") ]),
        el("div", { class:"hr" }),
        el("h4", {}, "ê³ ê¸‰ ì˜µì…˜"),
        el("div", { class:"flex-center", style:"justify-content:flex-start" }, [
            dangerToggle,
            el("span", { class:"muted" }, "ì‚­ì œ/í† í° ìˆ˜ë™ ì¡°ì • ë²„íŠ¼ í‘œì‹œ(ì£¼ì˜)")
        ])
      ])
    ])
  ]));

  // Table
  const table = el("table");
  table.appendChild(el("thead", {}, el("tr", {}, [
    el("th", {}, "ìˆœì„œ"),
    el("th", {}, "ì´ë¦„"),
    el("th", {}, el("div",{class:"row", style:"gap:4px"},[el("span",{},"ê³ ì •"), el("button",{class:"sm", onclick:()=>{setAllForLane("fixed",true);render()}},"All ON"),el("button",{class:"sm", onclick:()=>{setAllForLane("fixed",false);render()}},"OFF")])),
    el("th", {}, el("div",{class:"row", style:"gap:4px"},[el("span",{},"ì „ë¦¬"), el("button",{class:"sm", onclick:()=>{setAllForLane("loot",true);render()}},"All ON"),el("button",{class:"sm", onclick:()=>{setAllForLane("loot",false);render()}},"OFF")])),
    el("th", {}, "ëˆ„ì ìˆ˜ë ¹"),
    el("th", {}, "í† í°"),
    el("th", {}, "ìƒíƒœ(ê³ ì •)"),
    el("th", {}, "ìƒíƒœ(ì „ë¦¬)"),
    el("th", {}, "ê´€ë¦¬"),
  ])));

  const tbody = el("tbody");
  state.players.forEach((p, idx)=>{
    const fixedBadge = p.activeFixed ? el("span", {class:"badge on"}, "ON") : el("span", {class:"badge off"}, "OFF");
    const lootBadge  = p.activeLoot  ? el("span", {class:"badge on"}, "ON") : el("span", {class:"badge off"}, "OFF");

    const receivedFixed = canReceive("fixed", p.id) ? el("span", { class:"badge ready" }, "ëŒ€ê¸°") : el("span", { class:"badge done" }, "ì™„ë£Œ");
    const receivedLoot  = canReceive("loot", p.id)  ? el("span", { class:"badge ready" }, "ëŒ€ê¸°") : el("span", { class:"badge done" }, "ì™„ë£Œ");

    const manage = [];
    if(state.ui.showDangerButtons){
      manage.push(
        el("button", { class:"sm", onclick:()=>{ p.tokens += 1; logEvent("TOKEN_ADJUST","(ìˆ˜ë™)",p.id,`${p.name} í† í° +1`,{delta:+1}); saveState(); render(); }}, "+1"),
        el("button", { class:"sm", onclick:()=>{ if(p.tokens<=0) return; p.tokens -= 1; logEvent("TOKEN_ADJUST","(ìˆ˜ë™)",p.id,`${p.name} í† í° -1`,{delta:-1}); saveState(); render(); }}, "-1"),
        el("button", { class:"sm danger", onclick:()=>{
          if(!confirm("ì‚­ì œí• ê¹Œìš”?")) return;
          state.players = state.players.filter(x=>x.id !== p.id);
          delete state.batchReceivedFixed[p.id];
          delete state.batchReceivedLoot[p.id];
          logEvent("ROSTER_DELETE","(ëª…ë‹¨)",null,`ì‚­ì œ: ${p.name}`);
          saveState(); render();
        }}, "ğŸ—‘ï¸")
      );
    }

    const tr = el("tr", {}, [
      el("td", {}, el("div", { class:"flex-center", style:"justify-content:flex-start" }, [
        el("span", { class:"drag-handle", title:"ë“œë˜ê·¸ë¡œ ìˆœì„œ ë³€ê²½" }, "â‰¡"),
        el("span", { style:"margin-right:8px; width:20px;" }, String(idx+1)),
        el("button", { class:"sm", style:"padding:2px 6px;", onclick:()=>{ reorderPlayersByIndex(idx, -1); render(); }}, "â–²"),
        el("button", { class:"sm", style:"padding:2px 6px;", onclick:()=>{ reorderPlayersByIndex(idx, 1); render(); }}, "â–¼"),
      ])),
      el("td", { style:"font-weight:600" }, p.name),
      el("td", { onclick:()=>{ p.activeFixed=!p.activeFixed; clampPointer("fixed"); saveState(); render(); }, style:"cursor:pointer" }, fixedBadge),
      el("td", { onclick:()=>{ p.activeLoot=!p.activeLoot; clampPointer("loot"); saveState(); render(); }, style:"cursor:pointer" }, lootBadge),
      el("td", {}, `${p.fixedCount} / ${p.lootCount}`),
      el("td", { style:"font-weight:bold; color:var(--primary);" }, String(p.tokens)),
      el("td", {}, receivedFixed),
      el("td", {}, receivedLoot),
      el("td", {}, el("div", { class:"row", style:"gap:4px;" }, manage)),
    ]);

    // Drag & Drop
    tr.draggable = true;
    tr.addEventListener("dragstart", ()=>{ _dragPlayerId = p.id; });
    tr.addEventListener("dragend", ()=>{ _dragPlayerId = null; });
    tr.addEventListener("dragover", (e)=>{ e.preventDefault(); tr.classList.add("drag-over"); });
    tr.addEventListener("dragleave", ()=>{ tr.classList.remove("drag-over"); });
    tr.addEventListener("drop", (e)=>{ e.preventDefault(); tr.classList.remove("drag-over"); reorderPlayersById(_dragPlayerId, p.id); render(); });

    tbody.appendChild(tr);
  });
  table.appendChild(tbody);

  wrap.appendChild(el("div", { class:"card" }, [
    el("div", {class:"table-responsive"}, table)
  ]));

  // Catalog Mngt
  const catalogText = el("textarea", { rows:"4", placeholder:"ë„ê°\ní¬ê·€ ì¥ë¹„\nê°•í™”ì„" });
  catalogText.value = (state.lootCatalog || []).join("\n");
  
  const lootUrlInput = el("input", { value:"loot_items.txt", style:"flex:2" });

  wrap.appendChild(el("div", { class:"card" }, [
    el("details", {}, [
        el("summary", {}, "ğŸ“ ì „ë¦¬í…œ ëª©ë¡ ê´€ë¦¬"),
        el("div", {style:"margin-top:16px"}, [
            el("h4", {}, "ì§ì ‘ í¸ì§‘"),
            catalogText,
            el("div", { class:"row", style:"margin-top:8px" }, [
                el("button", { onclick:()=>{ setLootCatalogFromText(catalogText.value); render(); }}, "ëª©ë¡ ì €ì¥"),
                el("button", { onclick: exportLootCatalogTxt }, "ë‹¤ìš´ë¡œë“œ")
            ]),
            el("div", { class:"hr" }),
            el("h4", {}, "GitHub ë¶ˆëŸ¬ì˜¤ê¸°"),
            el("div", { class:"row" }, [
                lootUrlInput,
                el("button", { onclick: async()=>{ await fetchLootItemsFromUrl(lootUrlInput.value); render(); }}, "ë¶ˆëŸ¬ì˜¤ê¸°")
            ])
        ])
    ])
  ]));

  return wrap;
}

// View: Fixed Lane
function viewFixed(){
  const wrap = el("div");
  const peek = peekEligibleCurrent("fixed");
  const curDisplay = peek.player ? peek.player.name : "(ì—†ìŒ)";
  const n = laneCount("fixed");

  const itemNameInput = el("input", { value: state.fixedItemName, placeholder:"ì˜ˆ: ê³ ì • ë³´ìƒ ìƒì", style:"font-weight:bold;" });
  itemNameInput.addEventListener("input", ()=>{
    state.fixedItemName = itemNameInput.value.trim() || "ê³ ì •í…œ";
    saveState();
  });

  const startSel = el("select", { style:"flex:1;" });
  startSel.appendChild(el("option", { value:"" }, "í¬ì¸í„° ë³€ê²½(ì„ íƒ)"));
  lanePlayers("fixed").forEach(p => startSel.appendChild(el("option", { value:p.name }, p.name)));

  wrap.appendChild(el("div", { class:"card" }, [
    el("div", { style:"display:flex; justify-content:space-between; align-items:center;" }, [
        el("h3", { style:"margin:0" }, "ğŸ’ ê³ ì •í…œ ë ˆì¸"),
        el("button", { class:"primary sm", onclick:()=>{ startBatch(); render(); }}, "âš”ï¸ ìƒˆ ë°°ì¹˜ ì‹œì‘")
    ]),
    el("div", { class:"row", style:"margin-top:12px; margin-bottom:12px;" }, [
        el("span", { class:"pill" }, `ì°¸ì—¬: ${n}ëª…`),
        el("span", { class:"pill" }, `í¬ì¸í„°: ${n ? (pointerValue("fixed")+1) : 0}`),
        el("span", { class:"pill" }, `ì™„ë£Œ: ${batchSummary("fixed")}ëª…`),
    ]),
    
    // Main Action Box
    el("div", { class:"current-player-box" }, [
        el("div", { class:"muted" }, "í˜„ì¬ ì°¨ë¡€ (Target)"),
        el("div", { class:"current-player-name" }, curDisplay),
        peek.offset > 0 ? el("div", { class:"text-danger", style:"margin-bottom:8px; font-weight:600;" }, `â€» ì•ì„  ${peek.offset}ëª…(ë°°ì¹˜ ì™„ë£Œì) ìë™ ìŠ¤í‚µë¨`) : null,
        
        el("div", { class:"row", style:"justify-content:center; margin-top:16px;" }, [
            el("span", {style:"align-self:center;"}, "ì•„ì´í…œëª…: "),
            el("div", {style:"width:200px"}, itemNameInput)
        ]),

        el("div", { class:"row", style:"justify-content:center; margin-top:16px; gap:16px;" }, [
            el("button", { class:"primary", style:"padding:12px 24px; font-size:1.1rem;", onclick:()=>{
                if(!normalizePointerToEligible("fixed")) return;
                const cur = getCurrentEligible("fixed");
                if(!cur) return;
                cur.fixedCount += 1;
                state.fixedItemName = itemNameInput.value.trim() || "ê³ ì •í…œ";
                markReceived("fixed", cur.id);
                logEvent("FIXED_GIVE", state.fixedItemName, cur.id, `${cur.name}ì—ê²Œ ê³ ì •í…œ ì§€ê¸‰`, { which:"fixed", curId:cur.id, batchId: state.batchId });
                stepPointer("fixed", 1);
                render();
            }}, "ğŸ ì§€ê¸‰ (ë³¸ì¸ ìˆ˜ë ¹)"),
            
            el("button", { class:"danger", onclick:()=>{
                if(!normalizePointerToEligible("fixed")) return;
                const cur = getCurrentEligible("fixed");
                if(!cur) return;
                state.fixedItemName = itemNameInput.value.trim() || "ê³ ì •í…œ";
                logEvent("FIXED_SKIP", state.fixedItemName, cur.id, `${cur.name} ì°¨ë¡€ ìŠ¤í‚µ`, { which:"fixed", curId:cur.id, batchId: state.batchId });
                stepPointer("fixed", 1);
                render();
            }}, "â­ ìŠ¤í‚µ")
        ])
    ]),

    el("div", { class:"hr" }),
    
    // Priority Section
    el("div", { class:"row", style:"background:#fffbeb; padding:12px; border-radius:8px; border:1px solid #fcd34d;" }, [
        el("div", {style:"font-weight:600; color:#92400e; margin-right:8px;"}, "âš¡ ìš°ì„ ê¶Œ ì‚¬ìš©:"),
        el("div", {style:"flex:1"}, prioritySelector("fixed", (peek.player && peek.player.id) ? peek.player.id : "")),
        el("button", { onclick:()=>{
            const sel = wrap.querySelector("select"); // hacky but works in this scope
            if(!sel.value) return alert("ìš°ì„ ê¶Œ ìš”ì²­ìë¥¼ ì„ íƒí•˜ì„¸ìš”.");
            priorityGive("fixed", itemNameInput.value, sel.value);
            render();
        }}, "ì ìš© (í† í° ì°¨ê°)")
    ]),

    el("div", { class:"row", style:"margin-top:16px; justify-content:flex-end;" }, [
        startSel,
        el("button", { class:"sm", onclick:()=>{
            if(!startSel.value) return alert("ì„ íƒí•˜ì„¸ìš”");
            setPointerToName("fixed", startSel.value);
            render();
        }}, "ê°•ì œ ì´ë™")
    ])
  ]));

  return wrap;
}

// View: Loot Lane
function viewLoot(){
  const wrap = el("div");
  const peek = peekEligibleCurrent("loot");
  const curDisplay = peek.player ? peek.player.name : "(ì—†ìŒ)";
  const n = laneCount("loot");

  const itemInput = el("input", { placeholder:"ë“œëëœ ì•„ì´í…œ ì…ë ¥...", style:"font-weight:bold;" });
  
  const catSel = el("select", { style:"margin-bottom:8px;" });
  catSel.appendChild(el("option", { value:"" }, "ğŸ“‹ ëª©ë¡ì—ì„œ ì•„ì´í…œ ì„ íƒ..."));
  (state.lootCatalog || []).forEach(x => catSel.appendChild(el("option", { value:x }, x)));
  catSel.addEventListener("change", ()=>{ if(catSel.value) itemInput.value = catSel.value; });

  const startSel = el("select", { style:"flex:1;" });
  startSel.appendChild(el("option", { value:"" }, "í¬ì¸í„° ë³€ê²½(ì„ íƒ)"));
  lanePlayers("loot").forEach(p => startSel.appendChild(el("option", { value:p.name }, p.name)));

  wrap.appendChild(el("div", { class:"card" }, [
    el("div", { style:"display:flex; justify-content:space-between; align-items:center;" }, [
        el("h3", { style:"margin:0" }, "ğŸ² ì „ë¦¬í…œ ë ˆì¸"),
        el("button", { class:"primary sm", onclick:()=>{ startBatch(); render(); }}, "âš”ï¸ ìƒˆ ë°°ì¹˜ ì‹œì‘")
    ]),
    el("div", { class:"row", style:"margin-top:12px; margin-bottom:12px;" }, [
        el("span", { class:"pill" }, `ì°¸ì—¬: ${n}ëª…`),
        el("span", { class:"pill" }, `í¬ì¸í„°: ${n ? (pointerValue("loot")+1) : 0}`),
        el("span", { class:"pill" }, `ì™„ë£Œ: ${batchSummary("loot")}ëª…`),
    ]),

    // Main Action Box
    el("div", { class:"current-player-box" }, [
        el("div", { class:"muted" }, "í˜„ì¬ ì°¨ë¡€ (Target)"),
        el("div", { class:"current-player-name" }, curDisplay),
        peek.offset > 0 ? el("div", { class:"text-danger", style:"margin-bottom:8px; font-weight:600;" }, `â€» ì•ì„  ${peek.offset}ëª…(ë°°ì¹˜ ì™„ë£Œì) ìë™ ìŠ¤í‚µë¨`) : null,

        el("div", { class:"col", style:"max-width:400px; margin:16px auto;" }, [
            catSel,
            itemInput
        ]),

        el("div", { class:"row", style:"justify-content:center; gap:10px; flex-wrap:wrap;" }, [
            el("button", { class:"primary", style:"padding:12px 20px; font-size:1rem;", onclick:()=>{
                if(!normalizePointerToEligible("loot")) return;
                const cur = getCurrentEligible("loot");
                if(!cur) return;
                const itemName = safeText(itemInput.value);
                if(itemName === "(ë¯¸ì…ë ¥)") return alert("ì•„ì´í…œ ì´ë¦„ì„ ì…ë ¥í•˜ì„¸ìš”.");
                cur.lootCount += 1;
                markReceived("loot", cur.id);
                logEvent("LOOT_GIVE", itemName, cur.id, `${cur.name}ì—ê²Œ ì „ë¦¬í…œ ì§€ê¸‰`, { which:"loot", curId:cur.id, batchId: state.batchId });
                stepPointer("loot", 1);
                itemInput.value = ""; catSel.value = ""; render();
            }}, "ğŸ ì§€ê¸‰"),

            el("button", { class:"success", style:"padding:12px 20px; font-size:1rem;", onclick:()=>{
                if(!normalizePointerToEligible("loot")) return;
                const cur = getCurrentEligible("loot");
                if(!cur) return;
                const itemName = safeText(itemInput.value);
                cur.tokens += 1;
                logEvent("LOOT_PASS_TOKEN", itemName, cur.id, `${cur.name} íŒ¨ìŠ¤ (í† í°+1)`, { which:"loot", curId:cur.id, minted:1, batchId: state.batchId });
                stepPointer("loot", 1);
                itemInput.value = ""; catSel.value = ""; render();
            }}, "ğŸª™ íŒ¨ìŠ¤ (í† í°+1)"),

            el("button", { class:"danger", style:"padding:12px 20px; font-size:1rem;", onclick:()=>{
                if(!normalizePointerToEligible("loot")) return;
                const cur = getCurrentEligible("loot");
                if(!cur) return;
                const itemName = safeText(itemInput.value);
                logEvent("LOOT_SKIP", itemName, cur.id, `${cur.name} ìŠ¤í‚µ (ë³´ìƒX)`, { which:"loot", curId:cur.id, batchId: state.batchId });
                stepPointer("loot", 1);
                itemInput.value = ""; catSel.value = ""; render();
            }}, "â­ ìŠ¤í‚µ")
        ])
    ]),

    el("div", { class:"hr" }),

    // Priority
    el("div", { class:"row", style:"background:#fffbeb; padding:12px; border-radius:8px; border:1px solid #fcd34d;" }, [
        el("div", {style:"font-weight:600; color:#92400e; margin-right:8px;"}, "âš¡ ìš°ì„ ê¶Œ ì‚¬ìš©:"),
        el("div", {style:"flex:1"}, prioritySelector("loot", (peek.player && peek.player.id) ? peek.player.id : "")),
        el("button", { onclick:()=>{
            const sel = wrap.querySelectorAll("select")[2]; // hacky selector
            if(!sel || !sel.value) return alert("ìš°ì„ ê¶Œ ìš”ì²­ìë¥¼ ì„ íƒí•˜ì„¸ìš”.");
            priorityGive("loot", itemInput.value, sel.value);
            itemInput.value = ""; catSel.value = ""; render();
        }}, "ì ìš©")
    ]),

    el("div", { class:"row", style:"margin-top:16px; justify-content:flex-end;" }, [
        startSel,
        el("button", { class:"sm", onclick:()=>{
            if(!startSel.value) return alert("ì„ íƒí•˜ì„¸ìš”");
            setPointerToName("loot", startSel.value);
            render();
        }}, "ê°•ì œ ì´ë™")
    ])
  ]));

  return wrap;
}

// Logs
function viewLogs(){
  const wrap = el("div");

  const exportBtn = el("button", { onclick:exportJson }, "ğŸ’¾ JSON ë‚´ë³´ë‚´ê¸°");
  const importBtn = el("button", { onclick:importJson }, "ğŸ“‚ JSON ë¶ˆëŸ¬ì˜¤ê¸°");
  const resetBtn  = el("button", { class:"danger", onclick:resetAll }, "ğŸš« ì „ì²´ ì´ˆê¸°í™”");

  wrap.appendChild(el("div", { class:"card" }, [
    el("h3", {}, "ë°ì´í„° ê´€ë¦¬"),
    el("div", { class:"row" }, [exportBtn, importBtn, resetBtn])
  ]));

  const table = el("table");
  table.appendChild(el("thead", {}, el("tr", {}, [
    el("th", {}, "ì‹œê°„"),
    el("th", {}, "ìœ í˜•"),
    el("th", {}, "ì•„ì´í…œ"),
    el("th", {}, "ëŒ€ìƒ"),
    el("th", {}, "ë‚´ìš©"),
  ])));

  const tbody = el("tbody");
  state.logs.slice(0, 500).forEach(l=>{
    const receiver = l.receiverId ? (state.players.find(p=>p.id===l.receiverId) || null) : null;
    tbody.appendChild(el("tr", {}, [
      el("td", { class:"muted" }, fmt(l.ts).split(" ")[1]), // ì‹œê°„ë§Œ í‘œì‹œ
      el("td", {}, l.type),
      el("td", {}, l.itemName || "-"),
      el("td", { style:"font-weight:600" }, receiver ? receiver.name : "-"),
      el("td", { class:"muted" }, l.detail || ""),
    ]));
  });
  table.appendChild(tbody);

  wrap.appendChild(el("div", { class:"card" }, [
    el("h3", {}, `ìµœê·¼ ê¸°ë¡ (${state.logs.length}ê±´)`),
    el("div", {class:"table-responsive"}, table)
  ]));

  return wrap;
}

// Backup / Reset
function exportJson(){
  const blob = new Blob([JSON.stringify(state, null, 2)], { type:"application/json" });
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = `loot_state_${Date.now()}.json`;
  a.click();
  URL.revokeObjectURL(url);
}
function importJson(){
  const inp = document.createElement("input");
  inp.type = "file";
  inp.accept = "application/json";
  inp.onchange = () => {
    const file = inp.files && inp.files[0];
    if(!file) return;
    const reader = new FileReader();
    reader.onload = () => {
      try{
        const parsed = JSON.parse(String(reader.result));
        state = {
          ...defaultState(),
          ...parsed,
          ui: { ...defaultState().ui, ...(parsed.ui||{}) },
          batchReceivedFixed: parsed.batchReceivedFixed || {},
          batchReceivedLoot: parsed.batchReceivedLoot || {}
        };
        logEvent("IMPORT", "(ë°±ì—…)", null, "JSON ê°€ì ¸ì˜¤ê¸° ì™„ë£Œ");
        saveState();
        render();
      }catch(e){
        alert("JSON íŒŒì‹± ì‹¤íŒ¨");
      }
    };
    reader.readAsText(file);
  };
  inp.click();
}
function resetAll(){
  if(!confirm("âš ï¸ ê²½ê³ : ëª¨ë“  ë°ì´í„°ê°€ ì‚­ì œë©ë‹ˆë‹¤. ê³„ì†í•˜ì‹œê² ìŠµë‹ˆê¹Œ?")) return;
  state = defaultState();
  saveState();
  render();
}

// Init
setTab("roster");
if(state.batchId === null) startBatch();
</script>
</body>
</html>
